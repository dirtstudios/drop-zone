<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drop Zone - Kitchen Chaos</title>
    <style>
        body { margin: 0; overflow: hidden; background: #fff8dc; font-family: 'Segoe UI', Arial, sans-serif; }

        /* Loading screen */
        #loading {
            position: absolute; width: 100%; height: 100%;
            background: linear-gradient(135deg, #fff8dc 0%, #ffe4b5 50%, #ffdead 100%);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 300;
        }
        #loading h1 { font-size: 3.5em; margin-bottom: 5px; text-shadow: 2px 2px 8px rgba(0,0,0,0.15); }
        #loading p { font-size: 1.3em; color: #8b6914; margin: 10px 0; }
        .progress-bar {
            width: 300px; height: 16px; background: rgba(0,0,0,0.1);
            border-radius: 8px; overflow: hidden; margin-top: 15px;
            border: 2px solid rgba(139,105,20,0.3);
        }
        .progress-fill {
            width: 0%; height: 100%;
            background: linear-gradient(90deg, #ff6b35, #ffcc00, #44cc44);
            border-radius: 8px; transition: width 0.3s;
        }
        #loading-detail { font-size: 0.9em; color: #a0864a; margin-top: 8px; }

        #blocker {
            position: absolute; width: 100%; height: 100%;
            background: rgba(50,40,20,0.85); display: none;
            justify-content: center; align-items: center;
            z-index: 100;
        }
        #instructions {
            color: #2c1810; text-align: center; padding: 40px;
            background: linear-gradient(135deg, #deb887 0%, #d2b48c 25%, #cd853f 50%, #d2b48c 75%, #deb887 100%);
            border-radius: 20px;
            border: 4px solid #8b4513; cursor: pointer; max-width: 520px;
            box-shadow: 
                inset 0 2px 6px rgba(255,255,255,0.3),
                inset 0 -2px 6px rgba(0,0,0,0.2),
                0 6px 20px rgba(0,0,0,0.4);
            font-family: 'Georgia', 'Times New Roman', serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        #instructions h1 { color: #8b4513; margin-bottom: 10px; font-size: 2.6em; text-shadow: 1px 1px 3px rgba(255,255,255,0.4); }
        #instructions p { margin: 8px 0; font-size: 1.1em; }
        .key { background: #5a4020; padding: 4px 12px; border-radius: 5px; font-family: monospace; border: 1px solid #8a6a40; color: #ffe0a0; }
        .merge-chain { font-size: 1.2em; margin: 10px 0; line-height: 1.8; }
        .merge-chain span { margin: 0 2px; }

        #ui {
            position: absolute; top: 20px; left: 20px; color: #2c1810;
            background: linear-gradient(135deg, #deb887 0%, #d2b48c  25%, #cd853f  50%, #d2b48c 75%, #deb887 100%);
            padding: 20px 25px; border-radius: 15px;
            font-size: 15px; pointer-events: none; display: none;
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 4px 12px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
            font-family: 'Georgia', 'Times New Roman', serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        #ui h3 { margin: 0 0 10px 0; color: #ffcc00; }

        #combo-display {
            position: absolute; top: 20px; right: 20px; color: #f5e6c8;
            background: rgba(60,40,20,0.8); padding: 15px 20px; border-radius: 10px;
            font-size: 14px; pointer-events: none; display: none;
            backdrop-filter: blur(5px); border: 1px solid rgba(160,128,80,0.3);
            text-align: right;
        }
        #combo-text {
            font-size: 2em; font-weight: bold; color: #ffcc00;
            transition: transform 0.1s; display: none;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px; transform: translate(-50%, -50%);
            border: 2px solid rgba(100,70,30,0.6); border-radius: 50%;
            pointer-events: none; display: none;
            transition: border-color 0.15s, width 0.15s, height 0.15s, box-shadow 0.15s;
        }
        #crosshair.target {
            border-color: #ffcc00; width: 26px; height: 26px;
            box-shadow: 0 0 10px rgba(255,204,0,0.5);
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(100,70,30,0.6);
        }
        #crosshair::before { width: 2px; height: 8px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #crosshair::after { width: 8px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        #message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ffcc00; font-size: 2.5em; font-weight: bold; text-shadow: 0 0 30px #ffcc00;
            pointer-events: none; opacity: 0; transition: opacity 0.3s, transform 0.3s;
            z-index: 50;
        }
        #message.show { opacity: 1; transform: translate(-50%, -55%); }

        #tier-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: none; pointer-events: none;
            background: rgba(60,40,20,0.8); padding: 10px 20px; border-radius: 10px;
            backdrop-filter: blur(5px); border: 1px solid rgba(160,128,80,0.3);
            font-size: 1.4em;
        }
        .tier-icon { display: inline-block; margin: 0 2px; opacity: 0.4; transition: opacity 0.3s, transform 0.3s; vertical-align: middle; }
        .tier-icon.active { opacity: 1; transform: scale(1.3); }
        .tier-arrow { color: #8a6a40; margin: 0 2px; vertical-align: middle; font-size: 0.8em; }

        #warning-text {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #ff2222; font-size: 2em; font-weight: bold;
            text-shadow: 0 0 20px rgba(255,0,0,0.8);
            pointer-events: none; display: none; z-index: 50;
        }
        #warning-text.pulse { animation: warningPulse 1s ease-in-out infinite; }
        #warning-text.pulse-fast { animation: warningPulse 0.4s ease-in-out infinite; font-size: 3em; }
        @keyframes warningPulse {
            0%, 100% { opacity: 0.5; transform: translateX(-50%) scale(1); }
            50% { opacity: 1; transform: translateX(-50%) scale(1.15); }
        }

        #freeze-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(80,150,255,0.15); pointer-events: none;
            opacity: 0; transition: opacity 0.5s; z-index: 40;
        }

        #gameover-overlay {
            position: absolute; width: 100%; height: 100%;
            background: rgba(30,20,10,0.88); display: none;
            justify-content: center; align-items: center;
            z-index: 200; flex-direction: column;
        }
        #gameover-box {
            color: #2c1810; text-align: center; padding: 40px 60px;
            background: linear-gradient(135deg, #deb887 0%, #d2b48c 25%, #cd853f 50%, #d2b48c 75%, #deb887 100%);
            border-radius: 20px;
            border: 4px solid #8b4513; max-width: 500px;
            box-shadow: 
                inset 0 2px 6px rgba(255,255,255,0.3),
                inset 0 -2px 6px rgba(0,0,0,0.2),
                0 6px 20px rgba(0,0,0,0.4);
            font-family: 'Georgia', 'Times New Roman', serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        #gameover-box h1 { color: #8b4513; margin-bottom: 10px; font-size: 2.8em; text-shadow: 1px 1px 3px rgba(255,255,255,0.4); }
        #gameover-box .stat { margin: 8px 0; font-size: 1.2em; color: #2c1810; }
        #gameover-box .stat span { color: #8b4513; font-weight: bold; }
        #gameover-box .rank-display { font-size: 1.8em; margin: 15px 0; }
        #gameover-btn {
            margin-top: 20px; padding: 15px 40px; font-size: 1.3em; font-weight: bold;
            background: #ff4444; color: white; border: none; border-radius: 10px;
            cursor: pointer; transition: background 0.2s, transform 0.1s;
        }
        #gameover-btn:hover { background: #ff6666; transform: scale(1.05); }

        #powerup-indicator {
            position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%);
            color: #ffcc00; font-size: 1.3em; font-weight: bold;
            text-shadow: 0 0 15px rgba(255,204,0,0.6);
            pointer-events: none; display: none; z-index: 50;
        }

        .flash-red { animation: flashRed 0.5s ease-in-out infinite; }
        @keyframes flashRed {
            0%, 100% { color: #f5e6c8; }
            50% { color: #ff2222; }
        }

        /* Pause Menu */
        #pause-overlay {
            position: absolute; width: 100%; height: 100%;
            background: rgba(20,15,5,0.85); display: none;
            justify-content: center; align-items: center;
            z-index: 180; flex-direction: column;
            backdrop-filter: blur(4px);
        }
        #pause-box {
            color: #2c1810; text-align: center; padding: 40px 60px;
            background: linear-gradient(135deg, #deb887 0%, #d2b48c 25%, #cd853f 50%, #d2b48c 75%, #deb887 100%);
            border-radius: 20px;
            border: 4px solid #8b4513; max-width: 450px; min-width: 350px;
            box-shadow: 
                inset 0 2px 6px rgba(255,255,255,0.3),
                inset 0 -2px 6px rgba(0,0,0,0.2),
                0 6px 20px rgba(0,0,0,0.4);
            font-family: 'Georgia', 'Times New Roman', serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        #pause-box h1 { color: #8b4513; margin-bottom: 15px; font-size: 2.4em; text-shadow: 1px 1px 3px rgba(255,255,255,0.4); }
        .pause-btn {
            display: block; width: 100%; margin: 8px 0; padding: 12px 20px;
            font-size: 1.1em; font-weight: bold; border: 2px solid #8a6a40;
            border-radius: 8px; cursor: pointer; transition: all 0.2s;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        .pause-btn:hover { transform: scale(1.03); }
        .pause-btn.primary { background: #ffcc00; color: #2c1810; }
        .pause-btn.primary:hover { background: #ffe040; }
        .pause-btn.secondary { background: #5a4a3a; color: #f5e6c8; }
        .pause-btn.secondary:hover { background: #6a5a4a; }
        .pause-settings { margin: 15px 0; text-align: left; }
        .pause-settings label { display: flex; align-items: center; gap: 10px; margin: 8px 0; font-size: 0.95em; cursor: pointer; }
        .pause-settings input[type="range"] { flex: 1; accent-color: #ffcc00; cursor: pointer; }
        .pause-settings .slider-label { min-width: 80px; text-align: right; color: #ddc89a; }
        .pause-settings .slider-value { min-width: 35px; color: #ffcc00; font-weight: bold; }

        /* Achievement Toast */
        #achievement-toast {
            position: absolute; bottom: 80px; right: 20px;
            background: linear-gradient(135deg, rgba(50,30,10,0.95), rgba(80,50,20,0.95));
            border: 2px solid #ffcc00; border-radius: 12px;
            padding: 12px 20px; color: #f5e6c8; pointer-events: none;
            transform: translateX(120%); transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 160; max-width: 280px; box-shadow: 0 4px 20px rgba(255,204,0,0.3);
        }
        #achievement-toast.show { transform: translateX(0); }
        #achievement-toast .ach-icon { font-size: 1.8em; float: left; margin-right: 10px; }
        #achievement-toast .ach-title { color: #ffcc00; font-weight: bold; font-size: 1.1em; }
        #achievement-toast .ach-desc { color: #ddc89a; font-size: 0.85em; margin-top: 2px; }
        #achievement-toast .ach-label { color: #8a6a40; font-size: 0.7em; text-transform: uppercase; letter-spacing: 1px; }

        /* Mobile Touch Controls */
        #mobile-controls {
            display: none; position: fixed; width: 100%; height: 100%;
            top: 0; left: 0; pointer-events: none; z-index: 250;
        }
        
        .mobile-control {
            position: absolute; pointer-events: auto;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            color: rgba(255,255,255,0.8); font-size: 1.2em; font-weight: bold;
            user-select: none; touch-action: none; transition: all 0.1s;
        }
        
        .mobile-control:active, .mobile-control.active {
            background: rgba(255,204,0,0.3); border-color: rgba(255,204,0,0.6);
            color: #ffcc00; transform: scale(0.95);
        }
        
        #virtual-joystick {
            bottom: 60px; left: 60px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.05); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
        }
        
        #joystick-knob {
            width: 50px; height: 50px;
            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%; position: relative; transition: all 0.1s;
        }
        
        #joystick-knob.active {
            background: rgba(255,204,0,0.4); border-color: rgba(255,204,0,0.7);
        }
        
        #mobile-jump { bottom: 200px; right: 60px; width: 70px; height: 70px; }
        #mobile-grab { bottom: 120px; right: 140px; width: 60px; height: 60px; font-size: 1em; }
        #mobile-yeet { bottom: 60px; right: 140px; width: 60px; height: 60px; font-size: 1em; }
        #mobile-sprint { bottom: 140px; right: 60px; width: 50px; height: 50px; font-size: 0.9em; }

        /* Stats Panel (in pause menu) */
        .stats-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 6px 15px;
            text-align: left; margin: 10px 0; font-size: 0.9em;
        }
        .stats-grid .stat-label { color: #8a6a40; }
        .stats-grid .stat-value { color: #ffcc00; font-weight: bold; text-align: right; }

        /* Achievements Panel */
        #achievements-panel {
            position: absolute; width: 100%; height: 100%;
            background: rgba(20,15,5,0.92); display: none;
            justify-content: center; align-items: center;
            z-index: 185; flex-direction: column;
            backdrop-filter: blur(4px);
        }
        #achievements-box {
            color: #f5e6c8; padding: 30px 40px;
            background: rgba(50,30,15,0.95); border-radius: 20px;
            border: 2px solid #ffcc00; max-width: 550px; width: 90%;
            max-height: 80vh; overflow-y: auto;
        }
        #achievements-box h1 { color: #ffcc00; text-align: center; margin-bottom: 15px; }
        .ach-item {
            display: flex; align-items: center; gap: 12px; padding: 10px;
            border-bottom: 1px solid rgba(138,106,64,0.3); transition: opacity 0.3s;
        }
        .ach-item.locked { opacity: 0.4; }
        .ach-item .ach-emoji { font-size: 1.6em; min-width: 40px; text-align: center; }
        .ach-item .ach-info { flex: 1; }
        .ach-item .ach-name { font-weight: bold; color: #ffcc00; }
        .ach-item .ach-description { font-size: 0.85em; color: #ddc89a; }
        .ach-item .ach-status { font-size: 0.75em; color: #44cc44; }

        /* Upgrade items */
        .upgrade-item {
            display: flex; align-items: center; gap: 12px; padding: 12px;
            border-bottom: 1px solid rgba(138,106,64,0.3); transition: opacity 0.3s;
            background: rgba(70,50,30,0.3); border-radius: 8px; margin-bottom: 8px;
        }
        .upgrade-item.maxed { opacity: 0.6; }
        .upgrade-item .upgrade-emoji { font-size: 1.6em; min-width: 40px; text-align: center; }
        .upgrade-item .upgrade-info { flex: 1; }
        .upgrade-item .upgrade-name { font-weight: bold; color: #ffcc00; }
        .upgrade-item .upgrade-description { font-size: 0.85em; color: #ddc89a; }
        .upgrade-item .upgrade-level { font-size: 0.75em; color: #44cc44; }
        .upgrade-item .upgrade-cost { 
            padding: 6px 12px; background: #ffcc00; color: #2a1f10; border-radius: 6px; 
            font-weight: bold; cursor: pointer; font-size: 0.9em; min-width: 80px; text-align: center;
        }
        .upgrade-item .upgrade-cost.disabled { 
            background: #666; color: #999; cursor: not-allowed; 
        }
        .upgrade-item .upgrade-cost:hover:not(.disabled) { 
            background: #ffd700; transform: scale(1.05); 
        }
        .ach-item.locked .ach-name { color: #8a6a40; }
        .ach-item.locked .ach-emoji { filter: grayscale(1); }
        .ach-progress { color: #ffcc00; text-align: center; margin-top: 10px; font-size: 0.9em; }

        /* Music visualizer (subtle) */
        #music-visualizer {
            position: absolute; bottom: 5px; right: 5px;
            display: flex; gap: 2px; align-items: flex-end; height: 20px;
            pointer-events: none; opacity: 0.4; z-index: 10;
        }
        .viz-bar {
            width: 3px; background: #ffcc00; border-radius: 1px;
            transition: height 0.1s ease;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h1>üçï DROP ZONE</h1>
        <p>Loading kitchen...</p>
        <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
        <div id="loading-detail">Preparing ingredients...</div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <h1>üçï DROP ZONE: Kitchen Chaos</h1>
            <p>A Physics Merge Puzzler</p>
            <hr style="border-color:#8a6a40; margin: 15px 0;">
            <p><span class="key">WASD</span> Move | <span class="key">SHIFT</span> Sprint</p>
            <p><span class="key">SPACE</span> Jump</p>
            <p><span class="key">E</span> Grab / Release</p>
            <p><span class="key">Q</span> YEET! (throw grabbed object)</p>
            <p><span class="key">MOUSE</span> Look Around</p>
            <hr style="border-color:#8a6a40; margin: 15px 0;">
            <p style="color:#ddc89a;">Merge same foods to upgrade!</p>
            <div class="merge-chain">
                <span>üçì Strawberry</span> ‚Üí
                <span>üçé Apple</span> ‚Üí
                <span>üçä Orange</span> ‚Üí
                <span>üçâ Watermelon</span> ‚Üí
                <span>üéÉ Pumpkin</span> ‚Üí
                <span style="color:#ff69b4; font-weight:bold;">üéÇ CAKE</span>
            </div>
            <p style="color:#ffcc00; margin-top: 8px;">üéÇ CAKE breaks the floor ‚Üí Next level!</p>
            <p style="color:#ddc89a; font-size:0.9em;">Chain merges quickly for COMBO multipliers!</p>
            <p style="color:#ff4444; font-size:0.9em;">‚ö†Ô∏è Too many objects = GAME OVER!</p>
            <p style="color:#88ff88; font-size:0.9em;">‚ú® Collect power-ups: üß≤ Magnet | üí£ Bomb | ‚ùÑÔ∏è Freeze | üëë Golden Touch</p>
            <p style="color:#ddc89a; font-size:0.8em;">Press <span class="key">ESC</span> to pause</p>
            <br>
            
            <!-- Game Mode Selection -->
            <div style="margin: 15px 0; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                <button class="mode-btn" id="classic-btn" onclick="selectGameMode('classic')" style="background: #ffcc00; color: #2c1810; border: 2px solid #8a6a40; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.9em;">üèÜ CLASSIC</button>
                <button class="mode-btn" id="zen-btn" onclick="selectGameMode('zen')" style="background: #5a4a3a; color: #f5e6c8; border: 2px solid #8a6a40; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">üßò ZEN</button>
                <button class="mode-btn" id="timeattack-btn" onclick="selectGameMode('timeattack')" style="background: #5a4a3a; color: #f5e6c8; border: 2px solid #8a6a40; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">‚è±Ô∏è TIME ATTACK</button>
                <button class="mode-btn" id="puzzle-btn" onclick="selectGameMode('puzzle')" style="background: #5a4a3a; color: #f5e6c8; border: 2px solid #8a6a40; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">üß© PUZZLE</button>
                <button class="mode-btn" id="daily-btn" onclick="selectGameMode('daily')" style="background: #5a4a3a; color: #f5e6c8; border: 2px solid #8a6a40; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">üìÖ DAILY</button>
            </div>
            <p id="mode-description" style="color:#ddc89a; font-size:0.85em; margin: 8px 0;">Classic: Survive as long as possible! Game over at 40 objects.</p>
            <p id="daily-challenge-info" style="color:#88ff88; font-size:0.8em; margin: 5px 0; display: none;"></p>
            
            <p style="color:#ffcc00; font-size:1.2em;">[ CLICK TO START ]</p>
        </div>
    </div>

    <div id="gameover-overlay">
        <div id="gameover-box">
            <h1 id="gameover-title">GAME OVER</h1>
            <div class="rank-display" id="gameover-rank"></div>
            <div class="stat">Score: <span id="gameover-score">0</span></div>
            <div class="stat">Level: <span id="gameover-level">1</span></div>
            <div class="stat">Merges: <span id="gameover-merges">0</span></div>
            <div class="stat">High Score: <span id="gameover-highscore">0</span></div>
            <button id="gameover-btn">üîÑ PLAY AGAIN</button>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" style="position: absolute; width: 100%; height: 100%; background: rgba(20,15,5,0.92); display: none; justify-content: center; align-items: center; z-index: 250; flex-direction: column;">
        <div id="tutorial-box" style="color: #f5e6c8; text-align: center; padding: 50px; background: rgba(40,25,10,0.95); border-radius: 20px; border: 2px solid #ffcc00; max-width: 600px; position: relative;">
            <button id="tutorial-skip" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #aaa; font-size: 1.2em; cursor: pointer;">&times;</button>
            <h1 id="tutorial-title" style="color: #ffcc00; margin-bottom: 20px; font-size: 2.2em;">Welcome to Drop Zone!</h1>
            
            <!-- Slide 1: Movement -->
            <div id="tutorial-slide-1" class="tutorial-slide">
                <div style="font-size: 4em; margin: 20px 0;">üïπÔ∏è</div>
                <h2 style="color: #ff8844;">Movement & Navigation</h2>
                <p style="font-size: 1.1em; line-height: 1.6; margin: 20px 0;">
                    Use <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">WASD</span> to move around the kitchen<br>
                    Hold <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">SHIFT</span> to sprint<br>
                    Press <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">SPACE</span> to jump<br>
                    <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">MOUSE</span> to look around
                </p>
            </div>
            
            <!-- Slide 2: Interaction -->
            <div id="tutorial-slide-2" class="tutorial-slide" style="display: none;">
                <div style="font-size: 4em; margin: 20px 0;">ü§è</div>
                <h2 style="color: #44cc44;">Grab & Throw</h2>
                <p style="font-size: 1.1em; line-height: 1.6; margin: 20px 0;">
                    Press <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">E</span> to grab nearby objects<br>
                    Press <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">E</span> again to release them gently<br>
                    Press <span style="background: #5a4020; padding: 3px 8px; border-radius: 4px; color: #ffe0a0;">Q</span> to YEET objects away!<br>
                    Your crosshair will glow when objects are grabbable
                </p>
            </div>
            
            <!-- Slide 3: Merging -->
            <div id="tutorial-slide-3" class="tutorial-slide" style="display: none;">
                <div style="font-size: 2em; margin: 20px 0;">üçì + üçì = üçé</div>
                <h2 style="color: #ff4444;">Merge Magic</h2>
                <p style="font-size: 1.1em; line-height: 1.6; margin: 20px 0;">
                    When <strong>same food items touch</strong>, they merge into the next tier!<br>
                    <strong>üçì Strawberry ‚Üí üçé Apple ‚Üí üçä Orange ‚Üí üçâ Watermelon ‚Üí üéÉ Pumpkin ‚Üí üéÇ Cake</strong><br>
                    Chain merges quickly for <span style="color: #ffcc00; font-weight: bold;">COMBO bonuses!</span><br>
                    <span style="color: #ff69b4; font-weight: bold;">üéÇ Birthday Cakes</span> break the floor and advance levels!
                </p>
            </div>
            
            <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: center; align-items: center;">
                <button id="tutorial-prev" style="padding: 12px 20px; font-size: 1.1em; background: #5a4a3a; color: #f5e6c8; border: 2px solid #8a6a40; border-radius: 8px; cursor: pointer;">‚Üê Previous</button>
                <div id="tutorial-dots" style="display: flex; gap: 8px;">
                    <div class="tutorial-dot active" data-slide="1" style="width: 12px; height: 12px; background: #ffcc00; border-radius: 50%; cursor: pointer;"></div>
                    <div class="tutorial-dot" data-slide="2" style="width: 12px; height: 12px; background: #5a4a3a; border-radius: 50%; cursor: pointer;"></div>
                    <div class="tutorial-dot" data-slide="3" style="width: 12px; height: 12px; background: #5a4a3a; border-radius: 50%; cursor: pointer;"></div>
                </div>
                <button id="tutorial-next" style="padding: 12px 20px; font-size: 1.1em; background: #ffcc00; color: #2c1810; border: 2px solid #8a6a40; border-radius: 8px; cursor: pointer; font-weight: bold;">Next ‚Üí</button>
            </div>
        </div>
    </div>

    <div id="ui">
        <h3 style="margin: 0 0 12px 0; font-size: 1.3em; color: #8b4513; text-align: center; border-bottom: 2px solid #8b4513; padding-bottom: 8px; font-family: 'Georgia', serif;">
            üçï KITCHEN LEADERBOARD üçï
        </h3>
        <div>Level: <span id="level">1</span></div>
        <div>Multiplier: <span id="multiplier" style="color: #ffcc00; font-weight: bold;">1.0x</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Best: <span id="highscore">0</span></div>
        <div>Objects: <span id="objCount">0</span></div>
        <div id="timer-display" style="display: none; font-size: 1.1em; color: #ffcc00; font-weight: bold;">Time: <span id="timer">60</span>s</div>
        <div id="puzzle-objective" style="display: none; font-size: 1.1em; color: #ff69b4; font-weight: bold; border-top: 1px solid #8b4513; padding-top: 8px; margin-top: 8px;">
            <div style="color: #8b4513; font-size: 0.9em;">üß© Objective:</div>
            <div id="puzzle-text">Complete challenge</div>
            <div id="puzzle-progress" style="font-size: 0.9em; color: #cd853f;">Progress: <span id="puzzle-count">0</span>/<span id="puzzle-target">5</span></div>
        </div>
        <div>Multiplier: <span id="multiplier" style="color:#ffcc00;">1.0x</span></div>
        <div>Rank: <span id="rank-display">Kitchen Newbie üçì</span></div>
        <div>Holding: <span id="holding">Nothing</span></div>
    </div>
    <div id="combo-display">
        <div id="combo-text">x2 COMBO!</div>
        <div id="combo-timer" style="height:3px; background:#ffcc00; margin-top:5px; transition: width 0.1s;"></div>
    </div>
    <div id="crosshair"></div>
    <div id="message"></div>
    <div id="warning-text">‚ö†Ô∏è WARNING</div>
    <div id="freeze-overlay"></div>
    <div id="powerup-indicator"></div>
    <div id="tier-bar"></div>

    <!-- Pause Menu -->
    <div id="pause-overlay">
        <div id="pause-box">
            <h1>‚è∏Ô∏è PAUSED</h1>
            <div class="stats-grid" id="pause-stats">
                <span class="stat-label">Score:</span><span class="stat-value" id="ps-score">0</span>
                <span class="stat-label">Level:</span><span class="stat-value" id="ps-level">1</span>
                <span class="stat-label">Merges:</span><span class="stat-value" id="ps-merges">0</span>
                <span class="stat-label">Yeeted:</span><span class="stat-value" id="ps-yeeted">0</span>
                <span class="stat-label">Best Combo:</span><span class="stat-value" id="ps-combo">0</span>
                <span class="stat-label">Time:</span><span class="stat-value" id="ps-time">0:00</span>
            </div>
            <div class="pause-settings">
                <label>
                    <span class="slider-label">üéµ Music</span>
                    <input type="range" id="music-volume" min="0" max="100" value="40">
                    <span class="slider-value" id="music-vol-display">40%</span>
                </label>
                <label>
                    <span class="slider-label">üîä SFX</span>
                    <input type="range" id="sfx-volume" min="0" max="100" value="70">
                    <span class="slider-value" id="sfx-vol-display">70%</span>
                </label>
                <label>
                    <span class="slider-label">üìê FOV</span>
                    <input type="range" id="fov-slider" min="50" max="110" value="75">
                    <span class="slider-value" id="fov-display">75¬∞</span>
                </label>
            </div>
            <button class="pause-btn primary" id="pause-resume">‚ñ∂Ô∏è Resume</button>
            <button class="pause-btn secondary" id="pause-achievements">üèÜ Achievements</button>
            <button class="pause-btn secondary" id="pause-upgrades">ü™ô Upgrades</button>
            <button class="pause-btn secondary" id="pause-themes">üé® Themes</button>
            <button class="pause-btn secondary" id="pause-stats">üìä Stats</button>
            <button class="pause-btn secondary" id="pause-leaderboard">ü•á Leaderboard</button>
            <button class="pause-btn secondary" id="pause-restart">üîÑ Restart</button>
        </div>
    </div>

    <!-- Achievements Panel -->
    <div id="achievements-panel">
        <div id="achievements-box">
            <h1>üèÜ Achievements</h1>
            <div id="achievements-list"></div>
            <div class="ach-progress" id="ach-progress">0 / 15 Unlocked</div>
            <button class="pause-btn secondary" id="ach-back" style="margin-top:15px;">‚Üê Back</button>
        </div>
    </div>

    <!-- Upgrades Panel -->
    <div id="upgrades-panel" style="position: absolute; width: 100%; height: 100%; background: rgba(20,15,5,0.92); display: none; justify-content: center; align-items: center; z-index: 185; flex-direction: column; backdrop-filter: blur(4px);">
        <div id="upgrades-box" style="color: #f5e6c8; padding: 30px 40px; background: rgba(50,30,15,0.95); border-radius: 20px; border: 2px solid #ffcc00; max-width: 650px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h1 style="color: #ffcc00; text-align: center; margin-bottom: 15px;">ü™ô Upgrades Shop</h1>
            <div style="text-align: center; margin-bottom: 20px; font-size: 1.1em; color: #ffcc00;">
                <span id="coin-display">ü™ô 0 Coins</span>
            </div>
            <div id="upgrades-list"></div>
            <button class="pause-btn secondary" id="upgrades-back" style="margin-top:15px;">‚Üê Back</button>
        </div>
    </div>

    <!-- Stats Panel -->
    <div id="stats-panel" style="position: absolute; width: 100%; height: 100%; background: rgba(20,15,5,0.92); display: none; justify-content: center; align-items: center; z-index: 185; flex-direction: column; backdrop-filter: blur(4px);">
        <div id="stats-box" style="color: #f5e6c8; padding: 30px 40px; background: rgba(50,30,15,0.95); border-radius: 20px; border: 2px solid #ffcc00; max-width: 650px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h1 style="color: #ffcc00; text-align: center; margin-bottom: 15px;">üìä Statistics</h1>
            
            <!-- Session Stats -->
            <h3 style="color: #deb887; margin: 20px 0 10px 0; border-bottom: 1px solid #8a6a40; padding-bottom: 5px;">üéÆ Current Session</h3>
            <div class="stats-grid" id="session-stats">
                <span class="stat-label">Score:</span><span class="stat-value" id="ss-score">0</span>
                <span class="stat-label">Level:</span><span class="stat-value" id="ss-level">1</span>
                <span class="stat-label">Merges:</span><span class="stat-value" id="ss-merges">0</span>
                <span class="stat-label">Objects Yeeted:</span><span class="stat-value" id="ss-yeeted">0</span>
                <span class="stat-label">Best Combo:</span><span class="stat-value" id="ss-combo">0</span>
                <span class="stat-label">Session Time:</span><span class="stat-value" id="ss-time">0:00</span>
            </div>

            <!-- All-Time Stats -->
            <h3 style="color: #deb887; margin: 20px 0 10px 0; border-bottom: 1px solid #8a6a40; padding-bottom: 5px;">üèÜ All-Time Records</h3>
            <div class="stats-grid" id="alltime-stats">
                <span class="stat-label">High Score:</span><span class="stat-value" id="at-highscore">0</span>
                <span class="stat-label">Total Merges:</span><span class="stat-value" id="at-merges">0</span>
                <span class="stat-label">Total Yeeted:</span><span class="stat-value" id="at-yeeted">0</span>
                <span class="stat-label">Highest Combo:</span><span class="stat-value" id="at-combo">0</span>
                <span class="stat-label">Highest Level:</span><span class="stat-value" id="at-level">1</span>
                <span class="stat-label">Games Played:</span><span class="stat-value" id="at-games">0</span>
                <span class="stat-label">Total Playtime:</span><span class="stat-value" id="at-playtime">0h 0m</span>
                <span class="stat-label">Coins Earned:</span><span class="stat-value" id="at-coins">0</span>
            </div>

            <!-- Achievement Progress -->
            <h3 style="color: #deb887; margin: 20px 0 10px 0; border-bottom: 1px solid #8a6a40; padding-bottom: 5px;">üéñÔ∏è Achievement Progress</h3>
            <div style="margin: 10px 0; font-size: 0.95em;">
                <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                    <span>Unlocked:</span>
                    <span id="stats-ach-unlocked" style="color: #ffcc00; font-weight: bold;">0 / 15</span>
                </div>
                <div style="background: rgba(0,0,0,0.3); border-radius: 10px; height: 20px; overflow: hidden;">
                    <div id="stats-ach-progress" style="background: linear-gradient(90deg, #ffcc00, #ff6600); height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
            </div>

            <button class="pause-btn secondary" id="stats-back" style="margin-top:15px;">‚Üê Back</button>
        </div>
    </div>

    <!-- Themes Panel -->
    <div id="themes-panel" style="position: absolute; width: 100%; height: 100%; background: rgba(20,15,5,0.92); display: none; justify-content: center; align-items: center; z-index: 185; flex-direction: column; backdrop-filter: blur(4px);">
        <div id="themes-box" style="color: #f5e6c8; padding: 30px 40px; background: rgba(50,30,15,0.95); border-radius: 20px; border: 2px solid #ffcc00; max-width: 650px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h1 style="color: #ffcc00; text-align: center; margin-bottom: 15px;">üé® Theme Shop</h1>
            <div style="text-align: center; margin-bottom: 20px; font-size: 1.1em; color: #ffcc00;">
                <span id="themes-coin-display">ü™ô 0 Coins</span>
            </div>
            <div id="themes-list"></div>
            <button class="pause-btn secondary" id="themes-back" style="margin-top:15px;">‚Üê Back</button>
        </div>
    </div>

    <!-- Leaderboard Panel -->
    <div id="leaderboard-panel" style="position: absolute; width: 100%; height: 100%; background: rgba(20,15,5,0.92); display: none; justify-content: center; align-items: center; z-index: 185; flex-direction: column; backdrop-filter: blur(4px);">
        <div id="leaderboard-box" style="color: #f5e6c8; padding: 30px 40px; background: rgba(50,30,15,0.95); border-radius: 20px; border: 2px solid #ffcc00; max-width: 650px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h1 style="color: #ffcc00; text-align: center; margin-bottom: 15px;">ü•á High Scores</h1>
            
            <div id="leaderboard-list"></div>
            
            <!-- New High Score Entry Form -->
            <div id="new-score-entry" style="display: none; margin: 20px 0; padding: 20px; border: 2px solid #ffcc00; border-radius: 10px; background: rgba(255,204,0,0.1);">
                <h3 style="color: #ffcc00; margin-bottom: 10px;">üéâ New High Score!</h3>
                <div style="margin: 10px 0;">
                    <label style="color: #deb887; margin-right: 10px;">Your Name:</label>
                    <input type="text" id="player-name-input" maxlength="20" placeholder="Enter your name..." style="padding: 5px; border: 1px solid #8a6a40; border-radius: 5px; background: rgba(255,255,255,0.9); color: #2c1810; font-weight: bold;">
                </div>
                <div style="margin: 10px 0; text-align: center;">
                    <button id="save-high-score" style="padding: 8px 16px; border: 2px solid #8a6a40; border-radius: 5px; background: #ffcc00; color: #2c1810; font-weight: bold; cursor: pointer; margin-right: 10px;">Save Score</button>
                    <button id="cancel-high-score" style="padding: 8px 16px; border: 2px solid #8a6a40; border-radius: 5px; background: #5a4a3a; color: #f5e6c8; font-weight: bold; cursor: pointer;">Skip</button>
                </div>
            </div>
            
            <div style="text-align: center; margin: 15px 0; font-size: 0.9em; color: #8a6a40;">
                <button id="clear-leaderboard" style="padding: 6px 12px; border: 1px solid #8a6a40; border-radius: 5px; background: rgba(139,0,0,0.7); color: #ff6666; font-size: 0.8em; cursor: pointer;">Clear All Scores</button>
            </div>

            <button class="pause-btn secondary" id="leaderboard-back" style="margin-top:15px;">‚Üê Back</button>
        </div>
    </div>

    <!-- Achievement Toast -->
    <div id="achievement-toast">
        <div class="ach-label">üèÜ Achievement Unlocked!</div>
        <div><span class="ach-icon" id="toast-icon">üçì</span></div>
        <div class="ach-title" id="toast-title">First Merge</div>
        <div class="ach-desc" id="toast-desc">Merge your first pair of objects</div>
    </div>

    <!-- Mobile Touch Controls -->
    <div id="mobile-controls">
        <div id="virtual-joystick" class="mobile-control">
            <div id="joystick-knob"></div>
        </div>
        <div id="mobile-jump" class="mobile-control">‚Üë</div>
        <div id="mobile-grab" class="mobile-control">E</div>
        <div id="mobile-yeet" class="mobile-control">Q</div>
        <div id="mobile-sprint" class="mobile-control">‚ö°</div>
    </div>

    <!-- Music Visualizer -->
    <div id="music-visualizer">
        <div class="viz-bar" style="height:4px;"></div>
        <div class="viz-bar" style="height:6px;"></div>
        <div class="viz-bar" style="height:3px;"></div>
        <div class="viz-bar" style="height:8px;"></div>
        <div class="viz-bar" style="height:5px;"></div>
        <div class="viz-bar" style="height:7px;"></div>
        <div class="viz-bar" style="height:4px;"></div>
        <div class="viz-bar" style="height:6px;"></div>
    </div>

    <script>
        // Debug: detect if module script never executes
        window._moduleLoaded = false;
        setTimeout(() => {
            if (!window._moduleLoaded) {
                const detail = document.getElementById('loading-detail');
                if (detail) detail.textContent = 'ERROR: Game script failed to load. Check browser console (F12).';
                console.error('Module script never executed - CDN imports likely failed');
            }
        }, 10000);
    </script>
    <script type="importmap">
    {
        "imports": {
            "three": "./assets/three.module.js",
            "three/addons/controls/PointerLockControls.js": "./assets/PointerLockControls.js",
            "three/addons/loaders/GLTFLoader.js": "./assets/GLTFLoader.js",
            "three/addons/postprocessing/EffectComposer.js": "./assets/EffectComposer.js",
            "three/addons/postprocessing/RenderPass.js": "./assets/RenderPass.js",
            "three/addons/postprocessing/UnrealBloomPass.js": "./assets/UnrealBloomPass.js",
            "three/addons/postprocessing/ShaderPass.js": "./assets/ShaderPass.js",
            "cannon-es": "./assets/cannon-es.js",
            "three/addons/postprocessing/Pass.js": "./assets/Pass.js",
            "three/addons/postprocessing/MaskPass.js": "./assets/MaskPass.js",
            "three/addons/postprocessing/ShaderPass.js": "./assets/ShaderPass.js",
            "three/addons/shaders/CopyShader.js": "./assets/CopyShader.js",
            "three/addons/shaders/LuminosityHighPassShader.js": "./assets/LuminosityHighPassShader.js",
            "three/addons/utils/BufferGeometryUtils.js": "./assets/BufferGeometryUtils.js"
        }
    }
    </script>

    <script type="module">
        window._moduleLoaded = true;
        console.log('Module script executing...');
        import * as THREE from 'three';
        console.log('THREE loaded');
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import * as CANNON from 'cannon-es';
        console.log('All imports loaded');

        // === CONFIGURATION ===
        const ROOM_SIZE = 25;
        const WALL_HEIGHT = 12;
        const MAX_OBJECTS = 40;
        const YEET_FORCE = 80;
        const GRAB_DISTANCE = 15;
        const MOVE_SPEED = 3;
        const SPRINT_SPEED = 8;
        const JUMP_FORCE = 10;
        const COMBO_WINDOW = 3000;

        const BASE_SPAWN_INTERVAL = 4000;
        const SPAWN_INTERVAL_DECREASE = 200;
        const MIN_SPAWN_INTERVAL = 1500;

        // Announcer messages
        const MERGE_MESSAGES = ["MERGE!", "SMASH!", "COMBINED!", "FUSION!", "EVOLUTION!", "IT'S ALIVE!", "SCIENCE!", "TEAMWORK!", "DELICIOUS!", "CHEF'S KISS!"];
        const YEET_MESSAGES = ["YEET!", "GOODBYE!", "SEE YA!", "YOINK!", "BEGONE!", "FAREWELL!", "INTO ORBIT!", "HOME RUN!", "FOOD FIGHT!"];
        const GAMEOVER_MESSAGES = ["RIP", "SKILL ISSUE", "TOO MUCH FOOD", "KITCHEN OVERFLOW", "GAME OVER", "F IN CHAT", "BURNT!"];
        const FLOORBREAK_MESSAGES = ["FLOOR BREAK! üí•", "SHATTERED!", "GROUND FLOOR!", "TIMBER!", "DOWN WE GO!", "CAKE SMASH!"];
        const GRAB_MESSAGES = ["GOT IT!", "MINE!", "GRABBED!", "YOINK!"];

        // Rank system
        function getRank(s) {
            if (s >= 10000) return "Master Chef üëë";
            if (s >= 5000) return "Floor Breaker üéÇ";
            if (s >= 2500) return "Combo Chef üéÉ";
            if (s >= 1000) return "Yeet Master üçâ";
            if (s >= 500) return "Fruit Mixer üçä";
            if (s >= 100) return "Berry Pusher üçé";
            return "Kitchen Newbie üçì";
        }

        function randomPick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

        // Vignette shader for post-processing
        const VignetteShader = {
            uniforms: {
                tDiffuse: { value: null },
                intensity: { value: 0.5 },
                radius: { value: 0.85 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float intensity;
                uniform float radius;
                varying vec2 vUv;
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Calculate distance from center
                    vec2 center = vec2(0.5, 0.5);
                    float dist = distance(vUv, center);
                    
                    // Create vignette with smooth falloff
                    float vignette = 1.0 - smoothstep(radius, 1.0, dist * intensity);
                    
                    // Warm kitchen vignette color (subtle brown/orange tint)
                    vec3 vignetteColor = vec3(0.96, 0.94, 0.88);
                    
                    gl_FragColor = vec4(color.rgb * mix(vignetteColor, vec3(1.0), vignette), color.a);
                }
            `
        };

        // Chromatic aberration shader for dramatic high-tier merges
        const ChromaticAberrationShader = {
            uniforms: {
                tDiffuse: { value: null },
                intensity: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float intensity;
                varying vec2 vUv;
                
                void main() {
                    vec2 center = vec2(0.5, 0.5);
                    vec2 offset = (vUv - center) * intensity;
                    
                    // Sample RGB channels with different offsets for chromatic aberration
                    float r = texture2D(tDiffuse, vUv + offset).r;
                    float g = texture2D(tDiffuse, vUv).g;
                    float b = texture2D(tDiffuse, vUv - offset).b;
                    float a = texture2D(tDiffuse, vUv).a;
                    
                    gl_FragColor = vec4(r, g, b, a);
                }
            `
        };

        // Weighted spawn: ~85% tier 0, ~12% tier 1, ~3% tier 2. Never spawn 3-5 directly.
        function randomSpawnTier() {
            const r = Math.random();
            if (r < 0.85) return 0;
            if (r < 0.97) return 1;
            return 2;
        }

        // Tier definitions (6 tiers)
        const TIER_EMOJIS = ['üçì', 'üçé', 'üçä', 'üçâ', 'üéÉ', 'üéÇ'];

        const TIERS = [
            { name: 'Strawberry', color: 0xff4444, mass: 1, scale: 0.8, modelFile: 'assets/tier0_strawberry.glb',
              physicsShape: () => new CANNON.Sphere(0.4), restitution: 0.9, behavior: 'bouncy' },
            { name: 'Apple', color: 0x44cc44, mass: 2, scale: 1.0, modelFile: 'assets/tier1_apple.glb',
              physicsShape: () => new CANNON.Sphere(0.5), restitution: 0.7 },
            { name: 'Orange', color: 0xff8800, mass: 4, scale: 1.0, modelFile: 'assets/tier2_orange.glb',
              physicsShape: () => new CANNON.Sphere(0.5), restitution: 0.6, behavior: 'hot' },
            { name: 'Watermelon', color: 0x44ff44, mass: 8, scale: 1.5, modelFile: 'assets/tier3_watermelon.glb',
              physicsShape: () => new CANNON.Sphere(0.7), restitution: 0.4, behavior: 'ice' },
            { name: 'Pumpkin', color: 0xff8844, mass: 16, scale: 1.8, modelFile: 'assets/tier4_pumpkin.glb',
              physicsShape: () => new CANNON.Sphere(0.8), restitution: 0.3 },
            { name: 'Birthday Cake', color: 0xff69b4, mass: 50, scale: 2.0, modelFile: 'assets/tier5_cake.glb',
              physicsShape: () => new CANNON.Box(new CANNON.Vec3(1.0, 0.6, 1.0)), restitution: 0.1 }
        ];

        // Realistic juice colors for splatter particles
        const JUICE_COLORS = [
            0xcc2244, // Strawberry - deep red with pink
            0xddaa44, // Apple - golden yellow/amber 
            0xff6600, // Orange - bright orange juice
            0xff4466, // Watermelon - pink/red pulp
            0xff9933, // Pumpkin - orange flesh
            0xffeedd  // Birthday Cake - vanilla frosting splatter
        ];

        // Power-up definitions
        const POWERUP_TYPES = [
            { name: 'MAGNET', emoji: 'üß≤', glowColor: 0xffff00, message: 'MAGNET!', msgColor: '#ffff00' },
            { name: 'BOMB', emoji: 'üí£', glowColor: 0xff2200, message: 'BOOM!', msgColor: '#ff4400' },
            { name: 'FREEZE', emoji: '‚ùÑÔ∏è', glowColor: 0x44aaff, message: 'FREEZE!', msgColor: '#44aaff' },
            { name: 'GOLDEN_TOUCH', emoji: 'üëë', glowColor: 0xffcc00, message: 'GOLDEN TOUCH!', msgColor: '#ffcc00' }
        ];

        // === MODEL CACHE ===
        const loadedModels = new Map(); // tier index -> THREE.Group

        // === GLOBALS ===
        let fovSetting = 75;
        let scene, camera, renderer, controls, composer;
        let world, playerBody;
        let objects = [];
        let heldObject = null;
        let springConstraint = null;
        let score = 0;
        let canJump = true;
        let floorBody = null;
        let floorMesh = null;
        let floorGrid = null;
        let level = 1;
        let levelMultiplier = 1.0;
        let isFalling = false;
        let screenShake = 0;
        let highScore = parseInt(localStorage.getItem('dropzone_highscore')) || 0;
        let groundMat = null;
        let tierMaterials = []; // Array of materials, one per tier
        let playerMat = null;
        let floorBreakCooldown = false;
        let comboCount = 0;
        let comboTimer = null;
        let comboTimeLeft = 0;
        let comboStartTime = 0;
        let audioCtx = null;
        let backgroundMusic = null;
        let merging = new Set();
        let totalMerges = 0;
        let gameOver = false;
        let spawnInterval = BASE_SPAWN_INTERVAL;
        let spawnTimerId = null;
        let dangerSoundOsc = null;
        let dangerSoundGain = null;

        // Power-up state
        let activePowerupOnField = null;
        let powerupSpawnTimer = null;
        let goldenTouchActive = false;
        let freezeActive = false;
        let freezeTimer = null;
        let magnetActive = false;
        
        // Slow-mo state
        let slowMoActive = false;
        let slowMoTimer = null;
        let slowMoTimeScale = 1.0;
        let magnetTimer = null;

        // Chromatic aberration effect
        let chromaticAberrationPass = null;

        // Game modes
        let gameMode = 'classic'; // 'classic', 'zen', 'timeattack', 'puzzle', 'daily'
        
        // Daily challenge system
        let dailyChallenge = null;
        let dailySeed = 0;
        
        // Tutorial state
        let tutorialShown = localStorage.getItem('dropzone_tutorial_shown') === 'true';
        let currentTutorialSlide = 1;
        
        // Time Attack mode
        let timeAttackDuration = 60000; // 60 seconds in milliseconds
        let timeAttackStartTime = 0;
        let timeAttackTimeLeft = 0;
        let timeAttackTimerId = null;
        
        // Puzzle mode
        let currentPuzzleLevel = 1;
        let puzzleObjective = null;
        let puzzleProgress = 0;
        let puzzleCompleted = false;
        
        const PUZZLE_LEVELS = [
            { level: 1, objective: 'merge_count', target: 5, description: 'Perform 5 merges', reward: 100 },
            { level: 2, objective: 'create_tier', target: 2, tier: 2, description: 'Create 2 Oranges', reward: 150 },
            { level: 3, objective: 'combo', target: 3, description: 'Get a 3x combo', reward: 200 },
            { level: 4, objective: 'create_tier', target: 1, tier: 3, description: 'Create a Watermelon', reward: 250 },
            { level: 5, objective: 'score', target: 1000, description: 'Score 1,000 points', reward: 300 },
            { level: 6, objective: 'merge_count', target: 15, description: 'Perform 15 merges', reward: 400 },
            { level: 7, objective: 'combo', target: 5, description: 'Get a 5x combo', reward: 500 },
            { level: 8, objective: 'create_tier', target: 1, tier: 4, description: 'Create a Pumpkin', reward: 600 },
            { level: 9, objective: 'floor_break', target: 3, description: 'Break the floor 3 times', reward: 750 },
            { level: 10, objective: 'create_tier', target: 1, tier: 5, description: 'Create a Birthday Cake', reward: 1000 }
        ];

        // Pause state
        let isPaused = false;

        // Volume settings (persisted)
        let musicVolume = parseInt(localStorage.getItem('dropzone_music_vol') ?? '40') / 100;
        let sfxVolume = parseInt(localStorage.getItem('dropzone_sfx_vol') ?? '70') / 100;

        // Stats tracking (persisted)
        let stats = JSON.parse(localStorage.getItem('dropzone_stats') || 'null') || {
            totalMergesAllTime: 0,
            totalYeetsAllTime: 0,
            totalJumpsAllTime: 0,
            highestCombo: 0,
            totalTimePlayed: 0,    // in seconds
            totalGamesPlayed: 0,
            totalLevelsReached: 0,
            highestLevel: 0,
            totalFloorsSmashed: 0,
            totalPowerupsCollected: 0,
            totalObjectsSpawned: 0,
            totalBombsUsed: 0,
            totalFreezesUsed: 0,
            totalGoldenTouchesUsed: 0,
            totalMagnetsUsed: 0,
            totalCoins: 0,  // Currency for upgrades
            upgrades: {     // Purchased upgrades
                scoreMultiplier: 0,      // +20% score per level (max 5)
                mergeRadius: 0,          // +10% merge distance per level (max 3) 
                powerupChance: 0,        // +5% powerup spawn chance per level (max 4)
                comboTime: 0,            // +1s combo window per level (max 3)
                startingBonus: 0,        // Start with 100 bonus points per level (max 3)
                magnetDuration: 0,       // +2s magnet duration per level (max 3)
                goldenTouchBonus: 0,     // +50% golden touch multiplier per level (max 2)
                freezeDuration: 0        // +2s freeze duration per level (max 3)
            }
        };
        let sessionYeets = 0;
        let sessionBestCombo = 0;
        let sessionStartTime = 0;

        function saveStats() {
            localStorage.setItem('dropzone_stats', JSON.stringify(stats));
        }

        // === ACHIEVEMENT SYSTEM ===
        const ACHIEVEMENTS = [
            { id: 'first_merge', icon: 'üçì', name: 'First Taste', desc: 'Merge your first pair of foods', check: () => stats.totalMergesAllTime >= 1 },
            { id: 'merge_10', icon: 'üçé', name: 'Fruit Salad', desc: 'Perform 10 merges in total', check: () => stats.totalMergesAllTime >= 10 },
            { id: 'merge_100', icon: 'ü•ó', name: 'Kitchen Master', desc: 'Perform 100 merges in total', check: () => stats.totalMergesAllTime >= 100 },
            { id: 'merge_500', icon: 'üë®‚Äçüç≥', name: 'Michelin Star', desc: 'Perform 500 merges in total', check: () => stats.totalMergesAllTime >= 500 },
            { id: 'combo_3', icon: 'üî•', name: 'On Fire!', desc: 'Get a 3x combo', check: () => stats.highestCombo >= 3 },
            { id: 'combo_5', icon: 'üí•', name: 'Combo Maniac', desc: 'Get a 5x combo', check: () => stats.highestCombo >= 5 },
            { id: 'combo_10', icon: 'üåã', name: 'UNSTOPPABLE', desc: 'Get a 10x combo', check: () => stats.highestCombo >= 10 },
            { id: 'yeet_50', icon: 'üèà', name: 'Food Fight!', desc: 'Yeet 50 objects in total', check: () => stats.totalYeetsAllTime >= 50 },
            { id: 'level_5', icon: 'üèóÔ∏è', name: 'Floor Smasher', desc: 'Reach level 5', check: () => stats.highestLevel >= 5 },
            { id: 'level_10', icon: 'üè∞', name: 'Skyscraper', desc: 'Reach level 10', check: () => stats.highestLevel >= 10 },
            { id: 'score_1000', icon: 'üí∞', name: 'Thousandaire', desc: 'Score 1,000 points in a game', check: () => highScore >= 1000 },
            { id: 'score_5000', icon: 'üíé', name: 'Diamond Chef', desc: 'Score 5,000 points in a game', check: () => highScore >= 5000 },
            { id: 'score_10000', icon: 'üëë', name: 'Kitchen Royalty', desc: 'Score 10,000 points in a game', check: () => highScore >= 10000 },
            { id: 'time_30min', icon: '‚è∞', name: 'Dedicated Chef', desc: 'Play for 30 minutes total', check: () => (stats.totalTimePlayed + getSessionTimePlayed()) >= 1800 },
            { id: 'powerup_all', icon: '‚ú®', name: 'Collector', desc: 'Use every type of power-up', check: () => stats.totalBombsUsed > 0 && stats.totalFreezesUsed > 0 && stats.totalGoldenTouchesUsed > 0 && stats.totalMagnetsUsed > 0 }
        ];

        // === UPGRADE SYSTEM ===
        const UPGRADES = {
            scoreMultiplier: {
                name: 'Score Boost',
                icon: 'üíØ',
                desc: '+20% score per level',
                maxLevel: 5,
                baseCost: 50,
                costMultiplier: 2,
                getDesc: (level) => level === 0 ? '+20% score' : `+${20 * level}% score (Level ${level})`
            },
            mergeRadius: {
                name: 'Merge Magnet',
                icon: 'üß≤',
                desc: '+10% merge distance per level',
                maxLevel: 3,
                baseCost: 75,
                costMultiplier: 2.5,
                getDesc: (level) => level === 0 ? '+10% merge distance' : `+${10 * level}% distance (Level ${level})`
            },
            powerupChance: {
                name: 'Lucky Drops',
                icon: 'üçÄ',
                desc: '+5% powerup spawn chance per level',
                maxLevel: 4,
                baseCost: 100,
                costMultiplier: 2,
                getDesc: (level) => level === 0 ? '+5% powerup chance' : `+${5 * level}% powerups (Level ${level})`
            },
            comboTime: {
                name: 'Combo Master',
                icon: '‚è±Ô∏è',
                desc: '+1s combo window per level',
                maxLevel: 3,
                baseCost: 125,
                costMultiplier: 2,
                getDesc: (level) => level === 0 ? '+1s combo time' : `+${level}s combo time (Level ${level})`
            },
            startingBonus: {
                name: 'Head Start',
                icon: 'üöÄ',
                desc: 'Start with +100 bonus points per level',
                maxLevel: 3,
                baseCost: 80,
                costMultiplier: 2,
                getDesc: (level) => level === 0 ? '+100 starting points' : `+${100 * level} starting points (Level ${level})`
            },
            magnetDuration: {
                name: 'Super Magnet',
                icon: '‚ö°',
                desc: '+2s magnet powerup duration per level',
                maxLevel: 3,
                baseCost: 90,
                costMultiplier: 2,
                getDesc: (level) => level === 0 ? '+2s magnet time' : `+${2 * level}s magnet time (Level ${level})`
            }
        };

        function getUpgradeCost(upgradeKey) {
            const upgrade = UPGRADES[upgradeKey];
            const currentLevel = stats.upgrades[upgradeKey] || 0;
            if (currentLevel >= upgrade.maxLevel) return -1; // Max level
            return Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, currentLevel));
        }

        function canAffordUpgrade(upgradeKey) {
            const cost = getUpgradeCost(upgradeKey);
            return cost > 0 && stats.totalCoins >= cost;
        }

        function purchaseUpgrade(upgradeKey) {
            const cost = getUpgradeCost(upgradeKey);
            if (!canAffordUpgrade(upgradeKey)) return false;
            
            stats.totalCoins -= cost;
            stats.upgrades[upgradeKey]++;
            saveStats();
            return true;
        }

        function earnCoins(amount, reason = '') {
            stats.totalCoins += amount;
            if (reason && amount > 0) {
                showMessage(`+${amount} ü™ô ${reason}`, '#ffcc00');
            }
        }

        let unlockedAchievements = new Set(JSON.parse(localStorage.getItem('dropzone_achievements') || '[]'));
        let achievementToastQueue = [];
        let showingAchievementToast = false;

        function checkAchievements() {
            let newUnlocks = [];
            for (const ach of ACHIEVEMENTS) {
                if (!unlockedAchievements.has(ach.id) && ach.check()) {
                    unlockedAchievements.add(ach.id);
                    newUnlocks.push(ach);
                }
            }
            if (newUnlocks.length > 0) {
                localStorage.setItem('dropzone_achievements', JSON.stringify([...unlockedAchievements]));
                for (const ach of newUnlocks) {
                    achievementToastQueue.push(ach);
                }
                processAchievementToastQueue();
            }
        }

        function processAchievementToastQueue() {
            if (showingAchievementToast || achievementToastQueue.length === 0) return;
            showingAchievementToast = true;
            const ach = achievementToastQueue.shift();
            showAchievementToast(ach);
        }

        function showAchievementToast(ach) {
            const toast = document.getElementById('achievement-toast');
            document.getElementById('toast-icon').textContent = ach.icon;
            document.getElementById('toast-title').textContent = ach.name;
            document.getElementById('toast-desc').textContent = ach.desc;
            playSound('achievement');
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    showingAchievementToast = false;
                    processAchievementToastQueue();
                }, 400);
            }, 3500);
        }

        function getSessionTimePlayed() {
            if (sessionStartTime <= 0) return 0;
            return Math.floor((Date.now() - sessionStartTime) / 1000);
        }

        function renderAchievementsPanel() {
            const list = document.getElementById('achievements-list');
            list.innerHTML = '';
            let unlocked = 0;
            for (const ach of ACHIEVEMENTS) {
                const isUnlocked = unlockedAchievements.has(ach.id);
                if (isUnlocked) unlocked++;
                const div = document.createElement('div');
                div.className = 'ach-item' + (isUnlocked ? '' : ' locked');
                div.innerHTML = `
                    <div class="ach-emoji">${ach.icon}</div>
                    <div class="ach-info">
                        <div class="ach-name">${ach.name}</div>
                        <div class="ach-description">${ach.desc}</div>
                        ${isUnlocked ? '<div class="ach-status">‚úÖ Unlocked</div>' : ''}
                    </div>
                `;
                list.appendChild(div);
            }
            document.getElementById('ach-progress').textContent = `${unlocked} / ${ACHIEVEMENTS.length} Unlocked`;
        }

        function renderUpgradesPanel() {
            document.getElementById('coin-display').textContent = `ü™ô ${stats.totalCoins} Coins`;
            const list = document.getElementById('upgrades-list');
            list.innerHTML = '';
            
            for (const [key, upgrade] of Object.entries(UPGRADES)) {
                const currentLevel = stats.upgrades[key] || 0;
                const cost = getUpgradeCost(key);
                const canAfford = canAffordUpgrade(key);
                const isMaxed = currentLevel >= upgrade.maxLevel;
                
                const div = document.createElement('div');
                div.className = 'upgrade-item' + (isMaxed ? ' maxed' : '');
                
                let costButton = '';
                if (isMaxed) {
                    costButton = '<div class="upgrade-cost disabled">MAX</div>';
                } else if (canAfford) {
                    costButton = `<div class="upgrade-cost" onclick="buyUpgrade('${key}')">${cost} ü™ô</div>`;
                } else {
                    costButton = `<div class="upgrade-cost disabled">${cost} ü™ô</div>`;
                }
                
                div.innerHTML = `
                    <div class="upgrade-emoji">${upgrade.icon}</div>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${upgrade.name}</div>
                        <div class="upgrade-description">${upgrade.getDesc(currentLevel)}</div>
                        ${currentLevel > 0 ? `<div class="upgrade-level">Level ${currentLevel} / ${upgrade.maxLevel}</div>` : ''}
                    </div>
                    ${costButton}
                `;
                list.appendChild(div);
            }
        }

        function buyUpgrade(key) {
            if (purchaseUpgrade(key)) {
                playSound('powerup'); // Reuse powerup sound
                renderUpgradesPanel(); // Refresh display
                earnCoins(0, ''); // Just for the visual update
            }
        }

        // Make buyUpgrade available globally for onclick
        window.buyUpgrade = buyUpgrade;

        // === THEME SYSTEM ===
        const THEMES = {
            kitchen: {
                name: 'Cozy Kitchen',
                icon: 'üè†',
                desc: 'Warm home cooking vibes (Default)',
                cost: 0,
                unlocked: true,
                colors: {
                    background: 0xfff8dc,
                    floor: { primary: 0xd2b48c, secondary: 0xcd853f },
                    walls: 0xf5f5dc,
                    lighting: { ambient: 0x404040, hemisphere: { sky: 0xffffff, ground: 0x444444 } }
                }
            },
            bakery: {
                name: 'French Bakery',
                icon: 'ü•ê',
                desc: 'Elegant pastry shop atmosphere',
                cost: 150,
                unlocked: false,
                colors: {
                    background: 0xfaf0e6,
                    floor: { primary: 0xdaa520, secondary: 0xb8860b },
                    walls: 0xf0f8ff,
                    lighting: { ambient: 0x504030, hemisphere: { sky: 0xffe4e1, ground: 0x8b7355 } }
                }
            },
            neon: {
                name: 'Cyber Kitchen',
                icon: 'üåÉ',
                desc: 'Futuristic neon-lit cooking lab',
                cost: 300,
                unlocked: false,
                colors: {
                    background: 0x0a0a2e,
                    floor: { primary: 0x16213e, secondary: 0x0f3460 },
                    walls: 0x1a1a2e,
                    lighting: { ambient: 0x1e1e3f, hemisphere: { sky: 0x00ffff, ground: 0xff00ff } }
                }
            },
            autumn: {
                name: 'Autumn Cabin',
                icon: 'üçÇ',
                desc: 'Rustic cabin with fall colors',
                cost: 200,
                unlocked: false,
                colors: {
                    background: 0x8b4513,
                    floor: { primary: 0xd2691e, secondary: 0xa0522d },
                    walls: 0xdaa520,
                    lighting: { ambient: 0x3c2414, hemisphere: { sky: 0xff4500, ground: 0x8b4513 } }
                }
            },
            ice: {
                name: 'Ice Palace',
                icon: '‚ùÑÔ∏è',
                desc: 'Frozen wonderland kitchen',
                cost: 250,
                unlocked: false,
                colors: {
                    background: 0xe0ffff,
                    floor: { primary: 0xb0e0e6, secondary: 0x87ceeb },
                    walls: 0xf0f8ff,
                    lighting: { ambient: 0x4682b4, hemisphere: { sky: 0x87ceeb, ground: 0x4169e1 } }
                }
            }
        };

        let currentTheme = localStorage.getItem('dropzone_theme') || 'kitchen';
        let unlockedThemes = new Set(JSON.parse(localStorage.getItem('dropzone_themes') || '["kitchen"]'));

        function saveThemes() {
            localStorage.setItem('dropzone_themes', JSON.stringify([...unlockedThemes]));
            localStorage.setItem('dropzone_theme', currentTheme);
        }

        function unlockTheme(themeKey) {
            const theme = THEMES[themeKey];
            if (!theme || unlockedThemes.has(themeKey)) return false;
            
            if (stats.totalCoins >= theme.cost) {
                stats.totalCoins -= theme.cost;
                unlockedThemes.add(themeKey);
                saveThemes();
                saveStats();
                return true;
            }
            return false;
        }

        function switchTheme(themeKey) {
            if (!unlockedThemes.has(themeKey)) return;
            currentTheme = themeKey;
            saveThemes();
            applyTheme();
            showMessage(`üé® Theme switched to ${THEMES[themeKey].name}!`, '#ffcc00');
        }

        function applyTheme() {
            const theme = THEMES[currentTheme];
            if (!theme || !scene) return;
            
            // Update background
            scene.background = new THREE.Color(theme.colors.background);
            
            // Update lighting
            const lighting = theme.colors.lighting;
            scene.children.forEach(child => {
                if (child.type === 'AmbientLight') {
                    child.color = new THREE.Color(lighting.ambient);
                }
                if (child.type === 'HemisphereLight') {
                    child.color = new THREE.Color(lighting.hemisphere.sky);
                    child.groundColor = new THREE.Color(lighting.hemisphere.ground);
                }
            });
            
            // Update floor color (if floor exists)
            if (floorMesh && floorMesh.material) {
                floorMesh.material.color.set(theme.colors.floor.primary);
            }
        }

        function renderThemesPanel() {
            document.getElementById('themes-coin-display').textContent = `ü™ô ${stats.totalCoins} Coins`;
            const list = document.getElementById('themes-list');
            list.innerHTML = '';
            
            for (const [key, theme] of Object.entries(THEMES)) {
                const isUnlocked = unlockedThemes.has(key);
                const isCurrent = currentTheme === key;
                
                const div = document.createElement('div');
                div.style.cssText = `
                    display: flex; align-items: center; gap: 15px; padding: 15px;
                    margin: 10px 0; border: 2px solid #8a6a40; border-radius: 10px;
                    background: ${isCurrent ? 'rgba(255,204,0,0.2)' : 'rgba(0,0,0,0.2)'};
                    transition: all 0.2s;
                `;
                
                const icon = document.createElement('div');
                icon.textContent = theme.icon;
                icon.style.cssText = 'font-size: 2em; min-width: 50px; text-align: center;';
                
                const info = document.createElement('div');
                info.style.flex = '1';
                info.innerHTML = `
                    <div style="color: #ffcc00; font-weight: bold; font-size: 1.1em;">${theme.name}</div>
                    <div style="color: #ddc89a; font-size: 0.9em; margin-top: 2px;">${theme.desc}</div>
                `;
                
                const button = document.createElement('button');
                button.style.cssText = `
                    padding: 8px 16px; border: 2px solid #8a6a40; border-radius: 5px;
                    font-weight: bold; cursor: pointer; transition: all 0.2s;
                `;
                
                if (isCurrent) {
                    button.textContent = '‚úÖ Active';
                    button.style.cssText += 'background: #ffcc00; color: #2c1810;';
                    button.disabled = true;
                } else if (isUnlocked) {
                    button.textContent = 'üé® Use';
                    button.style.cssText += 'background: #5a4a3a; color: #f5e6c8;';
                    button.onclick = () => {
                        switchTheme(key);
                        renderThemesPanel();
                    };
                } else {
                    const canAfford = stats.totalCoins >= theme.cost;
                    button.textContent = `ü™ô ${theme.cost}`;
                    button.style.cssText += `background: ${canAfford ? '#228b22' : '#8b0000'}; color: white;`;
                    button.disabled = !canAfford;
                    if (canAfford) {
                        button.onclick = () => {
                            if (unlockTheme(key)) {
                                playSound('powerup');
                                renderThemesPanel();
                                showMessage(`üé® ${theme.name} unlocked!`, '#00ff00');
                            }
                        };
                    }
                }
                
                div.appendChild(icon);
                div.appendChild(info);
                div.appendChild(button);
                list.appendChild(div);
            }
        }

        // Apply theme on game start
        window.addEventListener('load', () => {
            // Delay theme application until scene is fully loaded
            setTimeout(applyTheme, 100);
        });

        // === LEADERBOARD SYSTEM ===
        let leaderboard = JSON.parse(localStorage.getItem('dropzone_leaderboard') || '[]');
        let pendingHighScore = null;

        function saveLeaderboard() {
            localStorage.setItem('dropzone_leaderboard', JSON.stringify(leaderboard));
        }

        function addHighScore(name, score, level, merges) {
            const entry = {
                name: name || 'Anonymous',
                score: score,
                level: level,
                merges: merges,
                date: new Date().toLocaleDateString()
            };
            
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score); // Sort by score descending
            leaderboard = leaderboard.slice(0, 10); // Keep only top 10
            
            saveLeaderboard();
            pendingHighScore = null;
        }

        function isNewHighScore(score) {
            if (leaderboard.length < 10) return true;
            return score > leaderboard[leaderboard.length - 1].score;
        }

        function showNewHighScoreForm(score, level, merges) {
            pendingHighScore = { score, level, merges };
            document.getElementById('new-score-entry').style.display = 'block';
            document.getElementById('player-name-input').value = '';
            document.getElementById('player-name-input').focus();
        }

        function hideNewHighScoreForm() {
            document.getElementById('new-score-entry').style.display = 'none';
            pendingHighScore = null;
        }

        function renderLeaderboard() {
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '';
            
            if (leaderboard.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: #8a6a40; font-style: italic; margin: 20px 0;">No high scores yet. Be the first!</div>';
                return;
            }
            
            leaderboard.forEach((entry, index) => {
                const rankEmoji = ['ü•á', 'ü•à', 'ü•â'][index] || `${index + 1}.`;
                
                const div = document.createElement('div');
                div.style.cssText = `
                    display: flex; align-items: center; gap: 15px; padding: 12px 15px;
                    margin: 8px 0; border: 1px solid #8a6a40; border-radius: 8px;
                    background: rgba(139,106,64,0.1); font-size: 0.95em;
                `;
                
                const rank = document.createElement('div');
                rank.textContent = rankEmoji;
                rank.style.cssText = 'min-width: 30px; text-align: center; font-size: 1.2em;';
                
                const nameScore = document.createElement('div');
                nameScore.style.flex = '1';
                nameScore.innerHTML = `
                    <div style="color: #ffcc00; font-weight: bold; font-size: 1.1em;">${entry.name}</div>
                    <div style="color: #ddc89a; font-size: 0.85em;">Score: ${entry.score.toLocaleString()}</div>
                `;
                
                const details = document.createElement('div');
                details.style.cssText = 'text-align: right; color: #8a6a40; font-size: 0.85em;';
                details.innerHTML = `
                    <div>Level ${entry.level}</div>
                    <div>${entry.merges} merges</div>
                    <div>${entry.date}</div>
                `;
                
                div.appendChild(rank);
                div.appendChild(nameScore);
                div.appendChild(details);
                list.appendChild(div);
            });
        }

        function clearLeaderboard() {
            if (confirm('Are you sure you want to clear all high scores? This cannot be undone.')) {
                leaderboard = [];
                saveLeaderboard();
                renderLeaderboard();
                showMessage('Leaderboard cleared!', '#ff6666');
            }
        }

        // Event listeners for leaderboard form
        function setupLeaderboardEvents() {
            document.getElementById('save-high-score').addEventListener('click', () => {
                const name = document.getElementById('player-name-input').value.trim();
                if (pendingHighScore) {
                    addHighScore(name, pendingHighScore.score, pendingHighScore.level, pendingHighScore.merges);
                    hideNewHighScoreForm();
                    renderLeaderboard();
                    showMessage('High score saved!', '#00ff00');
                }
            });
            
            document.getElementById('cancel-high-score').addEventListener('click', () => {
                hideNewHighScoreForm();
            });
            
            document.getElementById('player-name-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('save-high-score').click();
                }
            });
            
            document.getElementById('clear-leaderboard').addEventListener('click', clearLeaderboard);
        }

        function renderStatsPanel() {
            // Session stats
            const sessionTime = getSessionTimePlayed();
            const mins = Math.floor(sessionTime / 60);
            const secs = sessionTime % 60;
            
            document.getElementById('ss-score').textContent = score;
            document.getElementById('ss-level').textContent = level;
            document.getElementById('ss-merges').textContent = totalMerges;
            document.getElementById('ss-yeeted').textContent = sessionYeets;
            document.getElementById('ss-combo').textContent = sessionBestCombo;
            document.getElementById('ss-time').textContent = mins + ':' + String(secs).padStart(2, '0');
            
            // All-time stats
            const totalPlaytime = (stats.totalTimePlayed + sessionTime);
            const hours = Math.floor(totalPlaytime / 3600);
            const minutes = Math.floor((totalPlaytime % 3600) / 60);
            
            document.getElementById('at-highscore').textContent = highScore;
            document.getElementById('at-merges').textContent = stats.totalMergesAllTime;
            document.getElementById('at-yeeted').textContent = stats.totalYeetsAllTime;
            document.getElementById('at-combo').textContent = stats.highestCombo;
            document.getElementById('at-level').textContent = stats.highestLevel;
            document.getElementById('at-games').textContent = stats.totalGamesPlayed;
            document.getElementById('at-playtime').textContent = `${hours}h ${minutes}m`;
            document.getElementById('at-coins').textContent = stats.totalCoins;
            
            // Achievement progress
            const unlockedCount = unlockedAchievements.size;
            const totalCount = ACHIEVEMENTS.length;
            const progressPercent = (unlockedCount / totalCount) * 100;
            
            document.getElementById('stats-ach-unlocked').textContent = `${unlockedCount} / ${totalCount}`;
            document.getElementById('stats-ach-progress').style.width = progressPercent + '%';
        }

        // === PROCEDURAL MUSIC SYSTEM ===
        let musicNodes = null;
        let musicPlaying = false;
        let musicBeatCount = 0;
        let musicIntensity = 0; // 0 = calm, 1 = intense

        // Musical scale: C major pentatonic for kitchen vibes
        const MUSIC_NOTES = {
            // Base frequencies for chords
            C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.00, A3: 220.00,
            C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, A4: 440.00,
            C5: 523.25, E5: 659.25, G5: 783.99
        };

        // Chord progressions (warm, kitchen-y)
        const CHORD_PROGRESSIONS = [
            // I - vi - IV - V (classic warm)
            [['C3','E3','G3'], ['A3','C4','E4'], ['G3','C4','E4'], ['G3','D4','G4']],
            // I - IV - vi - V
            [['C3','E3','G3'], ['G3','C4','E4'], ['A3','C4','E4'], ['G3','D4','G4']],
            // I - iii - IV - I
            [['C3','E3','G3'], ['E3','G3','C4'], ['G3','C4','E4'], ['C3','E3','G3']]
        ];

        let currentProgression = 0;
        let currentChordIndex = 0;

        function startMusic() {
            if (!audioCtx || musicPlaying) return;
            musicPlaying = true;

            // Master gain for music
            const masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(musicVolume * 0.12, audioCtx.currentTime);
            masterGain.connect(audioCtx.destination);

            // Pad oscillators (sustained chords)
            const padGain = audioCtx.createGain();
            padGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            padGain.connect(masterGain);

            // Low-pass filter for warmth
            const padFilter = audioCtx.createBiquadFilter();
            padFilter.type = 'lowpass';
            padFilter.frequency.setValueAtTime(800, audioCtx.currentTime);
            padFilter.Q.setValueAtTime(1, audioCtx.currentTime);
            padFilter.connect(padGain);

            // Create 3 pad oscillators for triad chord
            const padOscs = [];
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(130, audioCtx.currentTime);
                const oscGain = audioCtx.createGain();
                oscGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                osc.connect(oscGain);
                oscGain.connect(padFilter);
                osc.start();
                padOscs.push({ osc, gain: oscGain });
            }

            // Sub bass oscillator
            const bassOsc = audioCtx.createOscillator();
            bassOsc.type = 'sine';
            bassOsc.frequency.setValueAtTime(65, audioCtx.currentTime);
            const bassGain = audioCtx.createGain();
            bassGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            const bassFilter = audioCtx.createBiquadFilter();
            bassFilter.type = 'lowpass';
            bassFilter.frequency.setValueAtTime(200, audioCtx.currentTime);
            bassOsc.connect(bassFilter);
            bassFilter.connect(bassGain);
            bassGain.connect(masterGain);
            bassOsc.start();

            // Arpeggio oscillator (plays notes in sequence)
            const arpOsc = audioCtx.createOscillator();
            arpOsc.type = 'triangle';
            const arpGain = audioCtx.createGain();
            arpGain.gain.setValueAtTime(0, audioCtx.currentTime);
            const arpFilter = audioCtx.createBiquadFilter();
            arpFilter.type = 'lowpass';
            arpFilter.frequency.setValueAtTime(2000, audioCtx.currentTime);
            arpOsc.connect(arpFilter);
            arpFilter.connect(arpGain);
            arpGain.connect(masterGain);
            arpOsc.start();

            // LFO for subtle pad wobble
            const lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.setValueAtTime(0.3, audioCtx.currentTime);
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.setValueAtTime(3, audioCtx.currentTime);
            lfo.connect(lfoGain);
            lfoGain.connect(padFilter.frequency);
            lfo.start();

            musicNodes = { masterGain, padOscs, padGain, padFilter, bassOsc, bassGain, bassFilter, arpOsc, arpGain, arpFilter, lfo, lfoGain };

            // Start the beat loop
            musicBeatLoop();
        }

        function musicBeatLoop() {
            if (!musicPlaying || !musicNodes || !audioCtx) return;

            const now = audioCtx.currentTime;
            const progression = CHORD_PROGRESSIONS[currentProgression];
            const chord = progression[currentChordIndex];

            // Update pad chord (smooth transition)
            for (let i = 0; i < 3; i++) {
                const freq = MUSIC_NOTES[chord[i]];
                musicNodes.padOscs[i].osc.frequency.exponentialRampToValueAtTime(freq, now + 0.5);
            }

            // Update bass note (root of chord)
            const bassNote = MUSIC_NOTES[chord[0]] / 2; // One octave down
            musicNodes.bassOsc.frequency.exponentialRampToValueAtTime(bassNote, now + 0.3);

            // Arpeggio pattern (plays chord notes in sequence, intensity-dependent)
            if (musicIntensity > 0.3) {
                const arpNotes = [
                    MUSIC_NOTES[chord[0]] * 2,
                    MUSIC_NOTES[chord[1]] * 2,
                    MUSIC_NOTES[chord[2]] * 2,
                    MUSIC_NOTES[chord[1]] * 2
                ];
                const arpInterval = Math.max(0.15, 0.4 - musicIntensity * 0.25);
                for (let i = 0; i < 4; i++) {
                    const t = now + i * arpInterval;
                    musicNodes.arpOsc.frequency.setValueAtTime(arpNotes[i], t);
                    musicNodes.arpGain.gain.setValueAtTime(0.08 * musicIntensity, t);
                    musicNodes.arpGain.gain.exponentialRampToValueAtTime(0.001, t + arpInterval * 0.8);
                }
            }

            // Advance chord
            currentChordIndex = (currentChordIndex + 1) % progression.length;
            musicBeatCount++;

            // Change progression every 16 beats
            if (musicBeatCount % 16 === 0) {
                currentProgression = (currentProgression + 1) % CHORD_PROGRESSIONS.length;
            }

            // Beat timing: slower when calm, faster when intense
            const beatTime = Math.max(800, 2000 - musicIntensity * 1200);
            setTimeout(musicBeatLoop, beatTime);
        }

        function updateMusicIntensity() {
            if (!musicNodes || !audioCtx) return;

            // Calculate intensity based on object count and game state
            const objRatio = objects.length / MAX_OBJECTS;
            const targetIntensity = Math.min(1.0, objRatio * 1.5);

            // Smooth interpolation
            musicIntensity += (targetIntensity - musicIntensity) * 0.05;

            const now = audioCtx.currentTime;

            // Update master volume
            musicNodes.masterGain.gain.setValueAtTime(musicVolume * (0.08 + musicIntensity * 0.08), now);

            // Filter opens up with intensity (more harmonics = more tension)
            const filterFreq = 400 + musicIntensity * 1200;
            musicNodes.padFilter.frequency.setValueAtTime(filterFreq, now);

            // LFO speeds up with intensity (more wobble = more tension)
            musicNodes.lfo.frequency.setValueAtTime(0.2 + musicIntensity * 1.5, now);
            musicNodes.lfoGain.gain.setValueAtTime(2 + musicIntensity * 15, now);

            // Bass gets louder with intensity
            musicNodes.bassGain.gain.setValueAtTime(0.1 + musicIntensity * 0.15, now);

            // Update visualizer
            updateMusicVisualizer();
        }

        function updateMusicVisualizer() {
            const bars = document.querySelectorAll('.viz-bar');
            bars.forEach((bar, i) => {
                const base = 3 + musicIntensity * 12;
                const variation = Math.sin(Date.now() * 0.003 * (i + 1)) * 4 * (0.3 + musicIntensity * 0.7);
                const beat = Math.sin(Date.now() * 0.008) > 0.7 ? 5 : 0;
                bar.style.height = Math.max(2, base + variation + beat * (i % 2)) + 'px';
            });
        }

        function stopMusic() {
            if (!musicNodes) return;
            musicPlaying = false;
            try {
                musicNodes.padOscs.forEach(p => { try { p.osc.stop(); } catch(e) {} });
                musicNodes.bassOsc.stop();
                musicNodes.arpOsc.stop();
                musicNodes.lfo.stop();
            } catch(e) {}
            musicNodes = null;
        }

        function setMusicVolume(vol) {
            musicVolume = vol;
            localStorage.setItem('dropzone_music_vol', Math.round(vol * 100));
            if (musicNodes && audioCtx) {
                musicNodes.masterGain.gain.setValueAtTime(vol * (0.08 + musicIntensity * 0.08), audioCtx.currentTime);
            }
        }

        function setSfxVolume(vol) {
            sfxVolume = vol;
            localStorage.setItem('dropzone_sfx_vol', Math.round(vol * 100));
        }

        function setFOV(fov) {
            fovSetting = fov;
            localStorage.setItem('dropzone_fov', fov);
            camera.fov = fov;
            camera.updateProjectionMatrix();
        }

        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        const direction = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();

        // === MOBILE TOUCH CONTROLS ===
        let isMobile = false;
        let joystickActive = false;
        let joystickStartPos = { x: 0, y: 0 };
        let joystickCurrentPos = { x: 0, y: 0 };
        
        function detectMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform));
        }
        
        function setupMobileControls() {
            isMobile = detectMobile();
            const mobileControls = document.getElementById('mobile-controls');
            
            if (isMobile) {
                mobileControls.style.display = 'block';
                setupJoystick();
                setupMobileButtons();
            } else {
                mobileControls.style.display = 'none';
            }
        }
        
        function setupJoystick() {
            const joystick = document.getElementById('virtual-joystick');
            const knob = document.getElementById('joystick-knob');
            
            function handleJoystickStart(e) {
                e.preventDefault();
                joystickActive = true;
                const rect = joystick.getBoundingClientRect();
                joystickStartPos.x = rect.left + rect.width / 2;
                joystickStartPos.y = rect.top + rect.height / 2;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                joystickCurrentPos.x = clientX;
                joystickCurrentPos.y = clientY;
                
                knob.classList.add('active');
                updateJoystick();
            }
            
            function handleJoystickMove(e) {
                if (!joystickActive) return;
                e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                joystickCurrentPos.x = clientX;
                joystickCurrentPos.y = clientY;
                updateJoystick();
            }
            
            function handleJoystickEnd(e) {
                e.preventDefault();
                joystickActive = false;
                knob.classList.remove('active');
                knob.style.transform = 'translate(0, 0)';
                
                // Reset movement keys
                keys.w = keys.a = keys.s = keys.d = false;
            }
            
            function updateJoystick() {
                const dx = joystickCurrentPos.x - joystickStartPos.x;
                const dy = joystickCurrentPos.y - joystickStartPos.y;
                const distance = Math.min(35, Math.sqrt(dx * dx + dy * dy)); // Max 35px from center
                const angle = Math.atan2(dy, dx);
                
                // Update knob position
                const knobX = Math.cos(angle) * distance;
                const knobY = Math.sin(angle) * distance;
                knob.style.transform = `translate(${knobX}px, ${knobY}px)`;
                
                // Convert to movement keys (threshold of 15px)
                if (distance > 15) {
                    const normalizedX = dx / distance;
                    const normalizedY = dy / distance;
                    
                    keys.w = normalizedY < -0.5;
                    keys.s = normalizedY > 0.5;
                    keys.a = normalizedX < -0.5;
                    keys.d = normalizedX > 0.5;
                } else {
                    keys.w = keys.a = keys.s = keys.d = false;
                }
            }
            
            // Touch events
            joystick.addEventListener('touchstart', handleJoystickStart);
            joystick.addEventListener('touchmove', handleJoystickMove);
            joystick.addEventListener('touchend', handleJoystickEnd);
            
            // Mouse events (for testing on desktop)
            joystick.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', handleJoystickMove);
            document.addEventListener('mouseup', handleJoystickEnd);
        }
        
        function setupMobileButtons() {
            const jumpBtn = document.getElementById('mobile-jump');
            const grabBtn = document.getElementById('mobile-grab');
            const yeetBtn = document.getElementById('mobile-yeet');
            const sprintBtn = document.getElementById('mobile-sprint');
            
            // Jump button
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.space = true;
                jumpBtn.classList.add('active');
            });
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.space = false;
                jumpBtn.classList.remove('active');
            });
            
            // Grab button
            grabBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                grabObject();
                grabBtn.classList.add('active');
            });
            grabBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                grabBtn.classList.remove('active');
            });
            
            // Yeet button
            yeetBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                yeetObject();
                yeetBtn.classList.add('active');
            });
            yeetBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                yeetBtn.classList.remove('active');
            });
            
            // Sprint button
            sprintBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.shift = true;
                sprintBtn.classList.add('active');
            });
            sprintBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.shift = false;
                sprintBtn.classList.remove('active');
            });
        }

        // === PRELOAD MODELS ===
        async function preloadModels() {
            const loader = new GLTFLoader();
            const progressFill = document.getElementById('progress-fill');
            const loadingDetail = document.getElementById('loading-detail');
            let loaded = 0;
            const total = TIERS.length;

            for (let i = 0; i < TIERS.length; i++) {
                const tier = TIERS[i];
                loadingDetail.textContent = `Loading ${tier.name}...`;
                try {
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load(tier.modelFile, resolve, undefined, reject);
                    });
                    const model = gltf.scene;
                    // Normalize model: center and fit to unit scale, then apply tier scale
                    const box = new THREE.Box3().setFromObject(model);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const normScale = 1.0 / maxDim;
                        model.scale.setScalar(normScale);
                    }
                    // Center the model
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    model.position.sub(center.multiplyScalar(model.scale.x));

                    // Enable shadows on all meshes
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    loadedModels.set(i, model);
                } catch (err) {
                    console.warn(`Failed to load model for ${tier.name}: ${err.message}. Using fallback geometry.`);
                    loadedModels.set(i, null); // Will use fallback
                }
                loaded++;
                const pct = (loaded / total) * 100;
                progressFill.style.width = pct + '%';
            }

            loadingDetail.textContent = 'Kitchen ready!';
            // Short delay for visual polish
            await new Promise(r => setTimeout(r, 400));

            // Hide loading, show start screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('blocker').style.display = 'flex';
        }

        // === AUDIO ===
        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            startBackgroundMusic();
        }

        // === ENHANCED AUDIO SYSTEM ===
        const soundBuffers = new Map();
        const loadingSounds = new Set();

        async function loadSoundBuffer(soundName) {
            if (loadingSounds.has(soundName)) return null; // Already loading
            if (soundBuffers.has(soundName)) return soundBuffers.get(soundName);
            
            loadingSounds.add(soundName);
            try {
                const response = await fetch(`assets/sounds/${soundName}.wav`);
                if (!response.ok) throw new Error('Sound not found');
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                soundBuffers.set(soundName, audioBuffer);
                loadingSounds.delete(soundName);
                return audioBuffer;
            } catch (error) {
                loadingSounds.delete(soundName);
                return null; // File not found, will use procedural
            }
        }

        function playSound(type, pitch) {
            if (!audioCtx) return;
            const vol = sfxVolume;
            
            // Try to load and play external sound first
            loadSoundBuffer(type).then(buffer => {
                if (buffer) {
                    // Play external sound file
                    const source = audioCtx.createBufferSource();
                    const gainNode = audioCtx.createGain();
                    source.buffer = buffer;
                    source.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    gainNode.gain.value = vol * 0.5; // Adjust volume for external sounds
                    source.start();
                    return; // External sound played successfully
                }
                
                // Fallback to procedural generation
                playProceduralSound(type, pitch);
            });
        }

        function playProceduralSound(type, pitch) {
            if (!audioCtx) return;
            const vol = sfxVolume;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            switch(type) {
                case 'merge': {
                    // Unique merge sounds per tier ‚Äî ascending pitch + richness
                    const tierIdx = pitch || 0;
                    const tierFreqs = [300, 380, 460, 560, 680, 800]; // Higher pitch = higher tier
                    const baseFreq = tierFreqs[Math.min(tierIdx, tierFreqs.length - 1)];
                    osc.type = tierIdx >= 4 ? 'triangle' : 'sine'; // Richer timbre for high tiers
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.8, now + 0.12);
                    osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.2, now + 0.25);
                    gain.gain.setValueAtTime(0.15 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                    osc.start(now); osc.stop(now + 0.35);
                    // Add harmonic overtone for tier 3+
                    if (tierIdx >= 3) {
                        const osc2 = audioCtx.createOscillator();
                        const g2 = audioCtx.createGain();
                        osc2.type = 'sine';
                        osc2.frequency.setValueAtTime(baseFreq * 2, now);
                        osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3, now + 0.15);
                        g2.gain.setValueAtTime(0.06 * vol, now);
                        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                        osc2.connect(g2); g2.connect(audioCtx.destination);
                        osc2.start(now); osc2.stop(now + 0.2);
                    }
                    break;
                }
                case 'yeet':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                    gain.gain.setValueAtTime(0.1 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    osc.start(now); osc.stop(now + 0.25);
                    break;
                case 'grab':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(500, now + 0.08);
                    gain.gain.setValueAtTime(0.08 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                    break;
                case 'floor_break':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
                    gain.gain.setValueAtTime(0.2 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                    osc.start(now); osc.stop(now + 0.6);
                    const noise = audioCtx.createBufferSource();
                    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
                    const data = buf.getChannelData(0);
                    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.2));
                    noise.buffer = buf;
                    const ng = audioCtx.createGain();
                    ng.gain.setValueAtTime(0.15 * vol, now);
                    ng.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                    noise.connect(ng); ng.connect(audioCtx.destination);
                    noise.start(now);
                    break;
                case 'combo':
                    osc.type = 'sine';
                    const base = 400 + (pitch || 0) * 80;
                    osc.frequency.setValueAtTime(base, now);
                    osc.frequency.exponentialRampToValueAtTime(base * 1.5, now + 0.1);
                    gain.gain.setValueAtTime(0.12 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                    break;
                case 'level':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523, now);
                    gain.gain.setValueAtTime(0.12 * vol, now);
                    gain.gain.setValueAtTime(0.12 * vol, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    osc.frequency.setValueAtTime(659, now + 0.12);
                    osc.frequency.setValueAtTime(784, now + 0.24);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'jump':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(250, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                    gain.gain.setValueAtTime(0.05 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    osc.start(now); osc.stop(now + 0.12);
                    break;
                case 'gameover':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(350, now);
                    osc.frequency.setValueAtTime(330, now + 0.25);
                    osc.frequency.setValueAtTime(300, now + 0.5);
                    osc.frequency.setValueAtTime(200, now + 0.75);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 1.2);
                    gain.gain.setValueAtTime(0.12 * vol, now);
                    gain.gain.setValueAtTime(0.12 * vol, now + 0.9);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 1.3);
                    osc.start(now); osc.stop(now + 1.3);
                    break;
                case 'powerup':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                    osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                    gain.gain.setValueAtTime(0.12 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                    osc.start(now); osc.stop(now + 0.35);
                    break;
                case 'bomb':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
                    gain.gain.setValueAtTime(0.25 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    const bNoise = audioCtx.createBufferSource();
                    const bBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.4, audioCtx.sampleRate);
                    const bData = bBuf.getChannelData(0);
                    for (let i = 0; i < bData.length; i++) bData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bData.length * 0.15));
                    bNoise.buffer = bBuf;
                    const bGain = audioCtx.createGain();
                    bGain.gain.setValueAtTime(0.2 * vol, now);
                    bGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    bNoise.connect(bGain); bGain.connect(audioCtx.destination);
                    bNoise.start(now);
                    break;
                case 'spawn': {
                    // Satisfying "pop" on object spawn
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.08);
                    gain.gain.setValueAtTime(0.04 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                    break;
                }
                case 'achievement': {
                    // Triumphant achievement jingle
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523, now);        // C5
                    osc.frequency.setValueAtTime(659, now + 0.1);  // E5
                    osc.frequency.setValueAtTime(784, now + 0.2);  // G5
                    osc.frequency.setValueAtTime(1047, now + 0.3); // C6
                    gain.gain.setValueAtTime(0.12 * vol, now);
                    gain.gain.setValueAtTime(0.12 * vol, now + 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    // Harmony
                    const osc2 = audioCtx.createOscillator();
                    const g2 = audioCtx.createGain();
                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(659, now);       // E5
                    osc2.frequency.setValueAtTime(784, now + 0.1); // G5
                    osc2.frequency.setValueAtTime(1047, now + 0.2);// C6
                    osc2.frequency.setValueAtTime(1319, now + 0.3);// E6
                    g2.gain.setValueAtTime(0.06 * vol, now);
                    g2.gain.setValueAtTime(0.06 * vol, now + 0.3);
                    g2.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                    osc2.connect(g2); g2.connect(audioCtx.destination);
                    osc2.start(now); osc2.stop(now + 0.8);
                    break;
                }
                case 'pause': {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
                    gain.gain.setValueAtTime(0.06 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                }
                case 'unpause': {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                    gain.gain.setValueAtTime(0.06 * vol, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                    break;
                }
            }
        }

        function startDangerSound() {
            if (!audioCtx || dangerSoundOsc) return;
            dangerSoundOsc = audioCtx.createOscillator();
            dangerSoundGain = audioCtx.createGain();
            dangerSoundOsc.type = 'sine';
            dangerSoundOsc.frequency.setValueAtTime(60, audioCtx.currentTime);
            dangerSoundGain.gain.setValueAtTime(0, audioCtx.currentTime);
            dangerSoundOsc.connect(dangerSoundGain);
            dangerSoundGain.connect(audioCtx.destination);
            dangerSoundOsc.start();
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.type = 'sine';
            lfo.frequency.setValueAtTime(2, audioCtx.currentTime);
            lfoGain.gain.setValueAtTime(0.04, audioCtx.currentTime);
            lfo.connect(lfoGain);
            lfoGain.connect(dangerSoundGain.gain);
            lfo.start();
            dangerSoundOsc._lfo = lfo;
            dangerSoundOsc._lfoGain = lfoGain;
        }

        function stopDangerSound() {
            if (dangerSoundOsc) {
                try { dangerSoundOsc._lfo.stop(); dangerSoundOsc.stop(); } catch(e) {}
                dangerSoundOsc = null; dangerSoundGain = null;
            }
        }

        function startBackgroundMusic() {
            if (!audioCtx || backgroundMusic) return;
            
            // Create ambient background music with multiple oscillators
            const masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(0.03, audioCtx.currentTime); // Very subtle volume
            masterGain.connect(audioCtx.destination);
            
            backgroundMusic = { oscillators: [], gains: [], filters: [], masterGain };
            
            // Base frequencies for a warm, kitchen-like ambient pad
            const baseFreqs = [130.81, 164.81, 196.00, 246.94]; // C3, E3, G3, B3 - cmaj7 chord
            
            baseFreqs.forEach((freq, i) => {
                // Main oscillator
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                // Low-pass filter for warmth
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800 + i * 200, audioCtx.currentTime);
                filter.Q.setValueAtTime(0.5, audioCtx.currentTime);
                
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                
                // Create slow LFO for gentle modulation
                const lfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();
                lfo.type = 'sine';
                lfo.frequency.setValueAtTime(0.1 + i * 0.05, audioCtx.currentTime); // Very slow
                lfoGain.gain.setValueAtTime(8, audioCtx.currentTime); // Subtle pitch modulation
                
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                
                // Connect audio chain
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                // Store references
                backgroundMusic.oscillators.push(osc);
                backgroundMusic.gains.push(gain);
                backgroundMusic.filters.push(filter);
                
                // Start everything
                osc.start();
                lfo.start();
                
                // Store LFO references too
                osc._lfo = lfo;
                osc._lfoGain = lfoGain;
            });
        }
        
        function stopBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.oscillators.forEach(osc => {
                    try {
                        if (osc._lfo) osc._lfo.stop();
                        osc.stop();
                    } catch(e) {}
                });
                backgroundMusic = null;
            }
        }
        

        // === CREATE FALLBACK MESH (if model fails to load) ===
        function createFallbackMesh(tier) {
            const t = TIERS[tier];
            const color = t.color;
            let geo;
            if (tier === 5) {
                geo = new THREE.BoxGeometry(2, 1.2, 2);
            } else {
                const sizes = [0.4, 0.5, 0.5, 0.7, 0.8];
                geo = new THREE.SphereGeometry(sizes[tier] || 0.5, 16, 16);
            }
            const mat = new THREE.MeshStandardMaterial({
                color, roughness: 0.4, metalness: 0.3,
                emissive: color, emissiveIntensity: 0.05
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // === CLONE MODEL FOR SPAWNING ===
        function cloneModelForTier(tier) {
            const template = loadedModels.get(tier);
            if (!template) {
                return createFallbackMesh(tier);
            }
            const clone = template.clone();
            const s = TIERS[tier].scale;
            clone.scale.set(s, s, s);
            // Re-apply normalized scale on top
            // The template was already normalized to unit scale; now we apply tier scale
            const templateScale = template.scale.x; // normalized scale factor
            clone.scale.setScalar(templateScale * s);

            clone.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // Clone material so we can modify emissive per-instance
                    child.material = child.material.clone();
                }
            });
            return clone;
        }

        // === INIT ===
        async function startGame() {
            // Preload models first
            await preloadModels();
            // Then initialize everything
            init();
            animate();
        }

        startGame();

        function init() {
            // Initialize level multiplier
            updateLevelMultiplier();
            
            // Three.js Scene ‚Äî Kitchen theme
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfff8dc);
            scene.fog = new THREE.Fog(0xfff8dc, 20, 55);

            camera = new THREE.PerspectiveCamera(fovSetting, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            // Post-processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            // Bloom disabled ‚Äî causes material uniform crashes in Three.js r160
            // const bloomPass = new UnrealBloomPass(
            //     new THREE.Vector2(window.innerWidth, window.innerHeight),
            //     0.3, 0.5, 0.8
            // );
            // composer.addPass(bloomPass);
            
            // Kitchen vignette effect for cozy atmosphere
            const vignettePass = new ShaderPass(VignetteShader);
            vignettePass.uniforms.intensity.value = 0.6;
            vignettePass.uniforms.radius.value = 0.8;
            composer.addPass(vignettePass);

            // Chromatic aberration for dramatic high-tier merges
            chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
            chromaticAberrationPass.uniforms.intensity.value = 0.0; // Start disabled
            composer.addPass(chromaticAberrationPass);

            // Kitchen Lighting ‚Äî warm ambient + overhead spotlight
            const ambient = new THREE.AmbientLight(0xffe8c8, 0.8);
            scene.add(ambient);

            // Overhead kitchen light (like pendant lamp)
            const spotLight = new THREE.SpotLight(0xfff0d0, 1.5, 40, Math.PI / 4, 0.5, 1);
            spotLight.position.set(0, WALL_HEIGHT - 1, 0);
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = 50;
            scene.add(spotLight);
            scene.add(spotLight.target); // targets (0,0,0)

            const dirLight = new THREE.DirectionalLight(0xffeedd, 0.6);
            dirLight.position.set(10, 18, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 1;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            // Warm fill light
            const pointLight = new THREE.PointLight(0xffcc88, 0.4, 30);
            pointLight.position.set(-5, 8, -5);
            scene.add(pointLight);

            // Hemisphere light for natural floor bounce
            const hemiLight = new THREE.HemisphereLight(0xfff5e6, 0xc49a6c, 0.3);
            scene.add(hemiLight);

            // Cannon.js World
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.solver.iterations = 10;
            world.allowSleep = true;

            // Materials
            groundMat = new CANNON.Material('ground');
            playerMat = new CANNON.Material('player');
            
            // Create tier-specific materials with custom bounce
            tierMaterials = [];
            for (let i = 0; i < TIERS.length; i++) {
                const tierMat = new CANNON.Material(`tier${i}_${TIERS[i].name.toLowerCase()}`);
                tierMaterials.push(tierMat);
                
                // Set up contact materials for this tier
                world.addContactMaterial(new CANNON.ContactMaterial(groundMat, tierMat, { 
                    friction: 0.5, 
                    restitution: TIERS[i].restitution 
                }));
                world.addContactMaterial(new CANNON.ContactMaterial(tierMat, playerMat, { 
                    friction: 0.1, 
                    restitution: 0.0 
                }));
                
                // Tier-to-tier contact materials (for bouncing off each other)
                for (let j = i; j < TIERS.length; j++) {
                    const otherTierMat = tierMaterials[j] || tierMat;
                    const avgRestitution = (TIERS[i].restitution + TIERS[j % TIERS.length].restitution) / 2;
                    world.addContactMaterial(new CANNON.ContactMaterial(tierMat, otherTierMat, { 
                        friction: 0.3, 
                        restitution: avgRestitution 
                    }));
                }
            }

            // Create Room
            createRoom(groundMat);

            // Player Body
            playerBody = new CANNON.Body({
                mass: 80,
                shape: new CANNON.Sphere(0.8),
                position: new CANNON.Vec3(0, 5, 0),
                linearDamping: 0.1, angularDamping: 1,
                fixedRotation: true,
                material: playerMat,
                allowSleep: false
            });
            world.addBody(playerBody);

            // Collision detection for merging
            world.addEventListener('beginContact', handleCollision);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            instructions.addEventListener('click', () => {
                if (!tutorialShown) {
                    initAudio();
                    showTutorial();
                } else {
                    controls.lock();
                    initAudio();
                }
            });
            controls.addEventListener('lock', () => {
                if (gameOver) return;
                blocker.style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('combo-display').style.display = 'block';
                document.getElementById('tier-bar').style.display = 'block';
                
                // Start music on first lock
                if (!musicPlaying) startMusic();
                
                // Start time attack timer if in time attack mode
                if (gameMode === 'timeattack') {
                    startTimeAttackTimer();
                }
                
                // Initialize puzzle mode if selected
                if (gameMode === 'puzzle') {
                    initializePuzzleMode();
                }
            });
            controls.addEventListener('unlock', () => {
                if (gameOver) return;
                if (isPaused) return; // Don't show start screen when paused
                blocker.style.display = 'flex';
                document.getElementById('ui').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('combo-display').style.display = 'none';
                document.getElementById('tier-bar').style.display = 'none';
            });

            document.getElementById('gameover-btn').addEventListener('click', () => {
                restartGame();
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);

            // Setup tutorial event listeners
            setupTutorialEventListeners();

            // Setup pause menu event listeners
            setupPauseMenu();
            
            // Setup leaderboard event listeners
            setupLeaderboardEvents();

            // Make selectGameMode available globally for HTML onclick handlers
            window.selectGameMode = selectGameMode;

            // Track session start time
            sessionStartTime = Date.now();
            stats.totalGamesPlayed++;

            // Build tier bar
            buildTierBar();

            // Spawn initial objects
            for (let i = 0; i < 10; i++) {
                spawnObject(randomSpawnTier());
            }

            startSpawnTimer();
            schedulePowerupSpawn();
        }

        // === SPAWN TIMER MANAGEMENT ===
        function getSpawnInterval() {
            return Math.max(MIN_SPAWN_INTERVAL, BASE_SPAWN_INTERVAL - (level - 1) * SPAWN_INTERVAL_DECREASE);
        }

        function startSpawnTimer() {
            if (spawnTimerId) clearInterval(spawnTimerId);
            
            // Zen mode doesn't auto-spawn objects
            if (gameMode === 'zen') return;
            
            spawnInterval = getSpawnInterval();
            
            // Time Attack mode spawns faster
            if (gameMode === 'timeattack') {
                spawnInterval = Math.max(1000, spawnInterval * 0.7); // 30% faster spawn
            }
            
            spawnTimerId = setInterval(() => {
                if (gameOver || freezeActive) return;
                
                // Time Attack mode has no object limit, Classic mode does
                const maxObjects = gameMode === 'timeattack' ? 100 : MAX_OBJECTS;
                
                if (objects.length < maxObjects && controls.isLocked) {
                    spawnObject(randomSpawnTier());
                    checkGameOver();
                }
            }, spawnInterval);
        }

        // === POWER-UP SYSTEM ===
        function schedulePowerupSpawn() {
            if (powerupSpawnTimer) clearTimeout(powerupSpawnTimer);
            
            // Apply powerup chance upgrade (reduce delay by 5% per level)
            const powerupUpgrade = (stats.upgrades.powerupChance || 0) * 0.05; // 5% per level
            const baseDelay = 20000 + Math.random() * 10000;
            const delay = baseDelay * (1 - powerupUpgrade);
            
            powerupSpawnTimer = setTimeout(() => {
                if (!gameOver && controls.isLocked && !activePowerupOnField) {
                    spawnPowerup();
                }
                schedulePowerupSpawn();
            }, delay);
        }

        function spawnPowerup() {
            if (activePowerupOnField) return;

            const typeIdx = Math.floor(Math.random() * POWERUP_TYPES.length);
            const pType = POWERUP_TYPES[typeIdx];

            const geo = new THREE.IcosahedronGeometry(0.5, 1);
            const mat = new THREE.MeshStandardMaterial({
                color: pType.glowColor, emissive: pType.glowColor,
                emissiveIntensity: 0.8, transparent: true, opacity: 0.9,
                roughness: 0.2, metalness: 0.5
            });
            const mesh = new THREE.Mesh(geo, mat);

            const x = (Math.random() - 0.5) * (ROOM_SIZE - 6);
            const z = (Math.random() - 0.5) * (ROOM_SIZE - 6);
            mesh.position.set(x, 1.5, z);
            scene.add(mesh);

            const light = new THREE.PointLight(pType.glowColor, 1.5, 8);
            light.position.set(x, 2, z);
            scene.add(light);

            activePowerupOnField = { mesh, light, type: pType, typeIdx, x, z, spawnTime: Date.now() };
        }

        function checkPowerupPickup() {
            if (!activePowerupOnField || !playerBody) return;
            const dx = playerBody.position.x - activePowerupOnField.x;
            const dz = playerBody.position.z - activePowerupOnField.z;
            if (Math.sqrt(dx * dx + dz * dz) < 2.0) {
                pickupPowerup(activePowerupOnField);
            }
        }

        function pickupPowerup(pu) {
            scene.remove(pu.mesh);
            scene.remove(pu.light);
            playSound('powerup');
            const pType = pu.type;
            activePowerupOnField = null;

            stats.totalPowerupsCollected++;
            switch (pType.name) {
                case 'MAGNET': activateMagnet(); stats.totalMagnetsUsed++; break;
                case 'BOMB': activateBomb(); stats.totalBombsUsed++; break;
                case 'FREEZE': activateFreeze(); stats.totalFreezesUsed++; break;
                case 'GOLDEN_TOUCH': activateGoldenTouch(); stats.totalGoldenTouchesUsed++; break;
            }
            checkAchievements();
            showMessage(pType.message, pType.msgColor);
        }

        function activateMagnet() {
            magnetActive = true;
            showPowerupIndicator('üß≤ MAGNET ACTIVE', '#ffff00');
            if (magnetTimer) clearTimeout(magnetTimer);
            
            // Apply magnet duration upgrade (+2s per level)
            const magnetUpgrade = (stats.upgrades.magnetDuration || 0) * 2000; // +2000ms per level
            const magnetDuration = 5000 + magnetUpgrade;
            
            magnetTimer = setTimeout(() => { magnetActive = false; hidePowerupIndicator(); }, magnetDuration);
        }

        function applyMagnetForce() {
            if (!magnetActive) return;
            for (let i = 0; i < objects.length; i++) {
                for (let j = i + 1; j < objects.length; j++) {
                    const a = objects[i], b = objects[j];
                    if (a.tier !== b.tier) continue;
                    if (a.tier >= TIERS.length - 1) continue;
                    const dx = b.body.position.x - a.body.position.x;
                    const dy = b.body.position.y - a.body.position.y;
                    const dz = b.body.position.z - a.body.position.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist < 8 && dist > 0.5) {
                        const force = 8 / (dist * dist + 1);
                        const fx = dx / dist * force;
                        const fy = dy / dist * force;
                        const fz = dz / dist * force;
                        a.body.applyForce(new CANNON.Vec3(fx, fy, fz));
                        b.body.applyForce(new CANNON.Vec3(-fx, -fy, -fz));
                    }
                }
            }
        }

        function activateBomb() {
            screenShake = 1.5;
            playSound('bomb');
            const px = playerBody.position.x;
            const py = playerBody.position.y;
            const pz = playerBody.position.z;
            spawnParticles(new CANNON.Vec3(px, py, pz), 0xff4400, 25);
            objects.forEach(o => {
                const dx = o.body.position.x - px;
                const dy = o.body.position.y - py;
                const dz = o.body.position.z - pz;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (dist < 6) {
                    const force = 60 / (dist + 0.5);
                    const dir = new CANNON.Vec3(dx, dy + 2, dz);
                    dir.normalize();
                    dir.scale(force, dir);
                    o.body.applyImpulse(dir);
                }
            });
        }

        function activateFreeze() {
            freezeActive = true;
            document.getElementById('freeze-overlay').style.opacity = '1';
            showPowerupIndicator('‚ùÑÔ∏è FREEZE ACTIVE', '#44aaff');
            if (freezeTimer) clearTimeout(freezeTimer);
            freezeTimer = setTimeout(() => {
                freezeActive = false;
                document.getElementById('freeze-overlay').style.opacity = '0';
                hidePowerupIndicator();
            }, 8000);
        }

        function activateGoldenTouch() {
            goldenTouchActive = true;
            showPowerupIndicator('üëë GOLDEN TOUCH', '#ffcc00');
        }

        function activateSlowMo() {
            if (slowMoActive) return; // Don't stack slow-mo
            slowMoActive = true;
            slowMoTimeScale = 0.3;
            showPowerupIndicator('‚è≥ SLOW MOTION', '#ffaa00');
            
            if (slowMoTimer) clearTimeout(slowMoTimer);
            slowMoTimer = setTimeout(() => {
                slowMoActive = false;
                slowMoTimeScale = 1.0;
                hidePowerupIndicator();
            }, 800); // 0.8 seconds of slow-mo
        }

        // Camera zoom punch effect for dramatic moments (floor break)
        function triggerCameraZoomPunch() {
            const originalFov = camera.fov;
            const punchIntensity = 15; // FOV increase amount
            const duration = 600; // milliseconds
            
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.3) {
                    // Zoom in phase (first 30% - sharp increase)
                    const zoomProgress = progress / 0.3;
                    const easeOut = 1 - Math.pow(1 - zoomProgress, 3);
                    camera.fov = originalFov + (punchIntensity * easeOut);
                } else {
                    // Zoom back phase (remaining 70% - gradual return)
                    const returnProgress = (progress - 0.3) / 0.7;
                    const easeIn = Math.pow(returnProgress, 2);
                    camera.fov = originalFov + (punchIntensity * (1 - easeIn));
                }
                
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Ensure exact reset
                    camera.fov = originalFov;
                    camera.updateProjectionMatrix();
                }
            };
            
            animate();
        }

        // Chromatic aberration flash for dramatic high-tier merges
        function triggerChromaticAberration(intensity = 0.008, duration = 400) {
            if (!chromaticAberrationPass) return;
            
            const maxIntensity = intensity;
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.2) {
                    // Sharp flash up (first 20%)
                    const flashProgress = progress / 0.2;
                    const easeOut = 1 - Math.pow(1 - flashProgress, 2);
                    chromaticAberrationPass.uniforms.intensity.value = maxIntensity * easeOut;
                } else {
                    // Gentle fade out (remaining 80%)
                    const fadeProgress = (progress - 0.2) / 0.8;
                    const easeIn = Math.pow(fadeProgress, 1.5);
                    chromaticAberrationPass.uniforms.intensity.value = maxIntensity * (1 - easeIn);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Ensure exact reset
                    chromaticAberrationPass.uniforms.intensity.value = 0.0;
                }
            };
            
            animate();
        }

        function showPowerupIndicator(text, color) {
            const el = document.getElementById('powerup-indicator');
            el.textContent = text;
            el.style.color = color;
            el.style.textShadow = `0 0 15px ${color}`;
            el.style.display = 'block';
        }

        function hidePowerupIndicator() {
            document.getElementById('powerup-indicator').style.display = 'none';
        }

        function updatePowerupVisuals() {
            if (!activePowerupOnField) return;
            const pu = activePowerupOnField;
            const t = Date.now() * 0.002;
            pu.mesh.rotation.y = t;
            pu.mesh.rotation.x = Math.sin(t * 0.7) * 0.3;
            pu.mesh.position.y = 1.5 + Math.sin(t * 1.5) * 0.2;
            pu.light.position.y = pu.mesh.position.y + 0.5;
            pu.light.intensity = 1.5 + Math.sin(t * 3) * 0.5;
        }

        // === DAILY CHALLENGE SYSTEM ===
        function generateDailySeed() {
            const today = new Date();
            const dateString = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
            let hash = 0;
            for (let i = 0; i < dateString.length; i++) {
                const char = dateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function generateDailyChallenge() {
            dailySeed = generateDailySeed();
            let rng = dailySeed;
            const next = () => { rng++; return seededRandom(rng); };
            
            const challenges = [
                {
                    type: 'score_target',
                    description: 'Reach {target} points in classic mode',
                    target: Math.floor(next() * 3000 + 2000), // 2000-5000
                    reward: 75,
                    icon: 'üéØ'
                },
                {
                    type: 'combo_streak',
                    description: 'Achieve a {target}x combo',
                    target: Math.floor(next() * 5 + 5), // 5-10
                    reward: 50,
                    icon: 'üî•'
                },
                {
                    type: 'merge_count',
                    description: 'Perform {target} merges in one game',
                    target: Math.floor(next() * 30 + 20), // 20-50
                    reward: 40,
                    icon: 'üçé'
                },
                {
                    type: 'time_survival',
                    description: 'Survive for {target} seconds',
                    target: Math.floor(next() * 120 + 180), // 180-300 (3-5 min)
                    reward: 60,
                    icon: '‚è∞'
                },
                {
                    type: 'level_reach',
                    description: 'Reach level {target}',
                    target: Math.floor(next() * 5 + 8), // 8-13
                    reward: 80,
                    icon: 'üèóÔ∏è'
                }
            ];
            
            const challenge = challenges[Math.floor(next() * challenges.length)];
            challenge.completed = isDailyChallengeCompleted();
            
            return challenge;
        }

        function isDailyChallengeCompleted() {
            const today = new Date().toDateString();
            const completed = localStorage.getItem('dropzone_daily_completed');
            return completed === today;
        }

        function completeDailyChallenge() {
            if (dailyChallenge && !dailyChallenge.completed) {
                const today = new Date().toDateString();
                localStorage.setItem('dropzone_daily_completed', today);
                dailyChallenge.completed = true;
                earnCoins(dailyChallenge.reward, `Daily Challenge Complete!`);
                showMessage(`üéâ Daily Challenge Complete! +${dailyChallenge.reward} coins!`, '#00ff00');
                updateDailyChallengeDisplay();
            }
        }

        function checkDailyChallengeProgress() {
            if (gameMode !== 'daily' || !dailyChallenge || dailyChallenge.completed) return;
            
            let completed = false;
            switch (dailyChallenge.type) {
                case 'score_target':
                    completed = score >= dailyChallenge.target;
                    break;
                case 'combo_streak':
                    completed = stats.highestCombo >= dailyChallenge.target;
                    break;
                case 'merge_count':
                    completed = totalMerges >= dailyChallenge.target;
                    break;
                case 'time_survival':
                    completed = getSessionTimePlayed() >= dailyChallenge.target;
                    break;
                case 'level_reach':
                    completed = level >= dailyChallenge.target;
                    break;
            }
            
            if (completed) {
                completeDailyChallenge();
            }
        }

        function updateDailyChallengeDisplay() {
            const infoEl = document.getElementById('daily-challenge-info');
            if (dailyChallenge) {
                const status = dailyChallenge.completed ? '‚úÖ Completed!' : 'üéØ Active';
                const rewardText = dailyChallenge.completed ? '' : ` (Reward: ${dailyChallenge.reward} coins)`;
                infoEl.textContent = `${dailyChallenge.icon} ${dailyChallenge.description.replace('{target}', dailyChallenge.target)} ${rewardText} ${status}`;
                infoEl.style.display = 'block';
            } else {
                infoEl.style.display = 'none';
            }
        }

        // === GAME MODE SELECTION ===
        function selectGameMode(mode) {
            gameMode = mode;
            
            // Update button styles
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.style.background = '#5a4a3a';
                btn.style.color = '#f5e6c8';
            });
            
            const selectedBtn = document.getElementById(mode + '-btn');
            selectedBtn.style.background = '#ffcc00';
            selectedBtn.style.color = '#2c1810';
            
            // Update description
            const description = document.getElementById('mode-description');
            const dailyInfo = document.getElementById('daily-challenge-info');
            
            if (mode === 'classic') {
                description.textContent = 'Classic: Survive as long as possible! Game over at 40 objects.';
                dailyInfo.style.display = 'none';
            } else if (mode === 'zen') {
                description.textContent = 'Zen Mode: Relax and merge forever. No game over, no time pressure.';
                dailyInfo.style.display = 'none';
            } else if (mode === 'timeattack') {
                description.textContent = 'Time Attack: Score as much as possible in 60 seconds! No object limit.';
                dailyInfo.style.display = 'none';
            } else if (mode === 'puzzle') {
                description.textContent = 'Puzzle Mode: Complete specific objectives to advance through challenges.';
                dailyInfo.style.display = 'none';
            } else if (mode === 'daily') {
                description.textContent = 'Daily Challenge: Complete today\'s special objective for bonus coins!';
                if (!dailyChallenge) {
                    dailyChallenge = generateDailyChallenge();
                }
                updateDailyChallengeDisplay();
            }
        }

        // === TUTORIAL SYSTEM ===
        function showTutorial() {
            if (tutorialShown) return;
            document.getElementById('tutorial-overlay').style.display = 'flex';
            currentTutorialSlide = 1;
            updateTutorialSlide();
        }
        
        function hideTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            tutorialShown = true;
            localStorage.setItem('dropzone_tutorial_shown', 'true');
        }
        
        function updateTutorialSlide() {
            // Hide all slides
            document.querySelectorAll('.tutorial-slide').forEach(slide => {
                slide.style.display = 'none';
            });
            
            // Show current slide
            document.getElementById(`tutorial-slide-${currentTutorialSlide}`).style.display = 'block';
            
            // Update dots
            document.querySelectorAll('.tutorial-dot').forEach((dot, index) => {
                if (index + 1 === currentTutorialSlide) {
                    dot.style.background = '#ffcc00';
                    dot.classList.add('active');
                } else {
                    dot.style.background = '#5a4a3a';
                    dot.classList.remove('active');
                }
            });
            
            // Update button states
            const prevBtn = document.getElementById('tutorial-prev');
            const nextBtn = document.getElementById('tutorial-next');
            
            prevBtn.style.opacity = currentTutorialSlide === 1 ? '0.5' : '1';
            prevBtn.style.cursor = currentTutorialSlide === 1 ? 'default' : 'pointer';
            
            if (currentTutorialSlide === 3) {
                nextBtn.textContent = 'Start Game! üçï';
                nextBtn.style.background = '#44cc44';
                nextBtn.style.borderColor = '#66dd66';
            } else {
                nextBtn.textContent = 'Next ‚Üí';
                nextBtn.style.background = '#ffcc00';
                nextBtn.style.borderColor = '#8a6a40';
            }
        }
        
        function setupTutorialEventListeners() {
            document.getElementById('tutorial-skip').addEventListener('click', hideTutorial);
            
            document.getElementById('tutorial-prev').addEventListener('click', () => {
                if (currentTutorialSlide > 1) {
                    currentTutorialSlide--;
                    updateTutorialSlide();
                }
            });
            
            document.getElementById('tutorial-next').addEventListener('click', () => {
                if (currentTutorialSlide < 3) {
                    currentTutorialSlide++;
                    updateTutorialSlide();
                } else {
                    // Last slide - start game
                    hideTutorial();
                    // Trigger the main game start
                    controls.lock();
                    initAudio();
                }
            });
            
            // Dot navigation
            document.querySelectorAll('.tutorial-dot').forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    currentTutorialSlide = index + 1;
                    updateTutorialSlide();
                });
            });
        }

        // === PAUSE MENU ===
        function setupPauseMenu() {
            // Volume sliders
            const musicSlider = document.getElementById('music-volume');
            const sfxSlider = document.getElementById('sfx-volume');
            const fovSlider = document.getElementById('fov-slider');
            
            musicSlider.value = Math.round(musicVolume * 100);
            sfxSlider.value = Math.round(sfxVolume * 100);
            fovSlider.value = fovSetting;
            document.getElementById('music-vol-display').textContent = musicSlider.value + '%';
            document.getElementById('sfx-vol-display').textContent = sfxSlider.value + '%';
            document.getElementById('fov-display').textContent = fovSlider.value + '¬∞';

            musicSlider.addEventListener('input', (e) => {
                setMusicVolume(parseInt(e.target.value) / 100);
                document.getElementById('music-vol-display').textContent = e.target.value + '%';
            });
            sfxSlider.addEventListener('input', (e) => {
                setSfxVolume(parseInt(e.target.value) / 100);
                document.getElementById('sfx-vol-display').textContent = e.target.value + '%';
            });
            fovSlider.addEventListener('input', (e) => {
                setFOV(parseInt(e.target.value));
                document.getElementById('fov-display').textContent = e.target.value + '¬∞';
            });

            // Buttons
            document.getElementById('pause-resume').addEventListener('click', () => unpauseGame());
            document.getElementById('pause-restart').addEventListener('click', () => {
                unpauseGame();
                restartGame();
            });
            document.getElementById('pause-achievements').addEventListener('click', () => {
                document.getElementById('pause-overlay').style.display = 'none';
                renderAchievementsPanel();
                document.getElementById('achievements-panel').style.display = 'flex';
            });
            document.getElementById('ach-back').addEventListener('click', () => {
                document.getElementById('achievements-panel').style.display = 'none';
                document.getElementById('pause-overlay').style.display = 'flex';
            });
            document.getElementById('pause-upgrades').addEventListener('click', () => {
                document.getElementById('pause-overlay').style.display = 'none';
                renderUpgradesPanel();
                document.getElementById('upgrades-panel').style.display = 'flex';
            });
            document.getElementById('upgrades-back').addEventListener('click', () => {
                document.getElementById('upgrades-panel').style.display = 'none';
                document.getElementById('pause-overlay').style.display = 'flex';
            });
            document.getElementById('pause-stats').addEventListener('click', () => {
                document.getElementById('pause-overlay').style.display = 'none';
                renderStatsPanel();
                document.getElementById('stats-panel').style.display = 'flex';
            });
            document.getElementById('stats-back').addEventListener('click', () => {
                document.getElementById('stats-panel').style.display = 'none';
                document.getElementById('pause-overlay').style.display = 'flex';
            });
            document.getElementById('pause-themes').addEventListener('click', () => {
                document.getElementById('pause-overlay').style.display = 'none';
                renderThemesPanel();
                document.getElementById('themes-panel').style.display = 'flex';
            });
            document.getElementById('themes-back').addEventListener('click', () => {
                document.getElementById('themes-panel').style.display = 'none';
                document.getElementById('pause-overlay').style.display = 'flex';
            });
            document.getElementById('pause-leaderboard').addEventListener('click', () => {
                document.getElementById('pause-overlay').style.display = 'none';
                renderLeaderboard();
                document.getElementById('leaderboard-panel').style.display = 'flex';
            });
            document.getElementById('leaderboard-back').addEventListener('click', () => {
                document.getElementById('leaderboard-panel').style.display = 'none';
                document.getElementById('pause-overlay').style.display = 'flex';
            });
        }

        function pauseGame() {
            if (gameOver || !controls.isLocked) return;
            isPaused = true;
            controls.unlock();
            playSound('pause');
            
            // Update pause stats
            const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            document.getElementById('ps-score').textContent = score;
            document.getElementById('ps-level').textContent = level;
            document.getElementById('ps-merges').textContent = totalMerges;
            document.getElementById('ps-yeeted').textContent = sessionYeets;
            document.getElementById('ps-combo').textContent = sessionBestCombo;
            document.getElementById('ps-time').textContent = mins + ':' + String(secs).padStart(2, '0');

            // Show pause menu
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'flex';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('combo-display').style.display = 'none';
            document.getElementById('tier-bar').style.display = 'none';

            // Dim music during pause
            if (musicNodes && audioCtx) {
                musicNodes.masterGain.gain.linearRampToValueAtTime(musicVolume * 0.03, audioCtx.currentTime + 0.3);
            }
        }

        function unpauseGame() {
            isPaused = false;
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('achievements-panel').style.display = 'none';
            document.getElementById('upgrades-panel').style.display = 'none';
            document.getElementById('stats-panel').style.display = 'none';
            document.getElementById('themes-panel').style.display = 'none';
            document.getElementById('leaderboard-panel').style.display = 'none';
            playSound('unpause');

            // Restore music volume
            if (musicNodes && audioCtx) {
                musicNodes.masterGain.gain.linearRampToValueAtTime(
                    musicVolume * (0.08 + musicIntensity * 0.08), audioCtx.currentTime + 0.3
                );
            }

            controls.lock();
        }

        // === TIME ATTACK MODE ===
        function startTimeAttackTimer() {
            timeAttackStartTime = Date.now();
            timeAttackTimeLeft = timeAttackDuration;
            document.getElementById('timer-display').style.display = 'block';
            
            timeAttackTimerId = setInterval(() => {
                updateTimeAttackTimer();
            }, 100); // Update every 100ms for smooth countdown
        }
        
        function updateTimeAttackTimer() {
            const elapsed = Date.now() - timeAttackStartTime;
            timeAttackTimeLeft = Math.max(0, timeAttackDuration - elapsed);
            
            const seconds = Math.ceil(timeAttackTimeLeft / 1000);
            const timerEl = document.getElementById('timer');
            timerEl.textContent = seconds;
            
            // Flash red when time is running out
            if (seconds <= 10) {
                timerEl.style.color = seconds % 2 === 0 ? '#ff2222' : '#ffcc00';
            }
            
            if (timeAttackTimeLeft <= 0) {
                triggerGameOver();
            }
        }
        
        function stopTimeAttackTimer() {
            if (timeAttackTimerId) {
                clearInterval(timeAttackTimerId);
                timeAttackTimerId = null;
            }
            document.getElementById('timer-display').style.display = 'none';
        }
        
        // === PUZZLE MODE ===
        function initializePuzzleMode() {
            currentPuzzleLevel = 1;
            puzzleProgress = 0;
            puzzleCompleted = false;
            loadPuzzleLevel(currentPuzzleLevel);
            document.getElementById('puzzle-objective').style.display = 'block';
        }
        
        function loadPuzzleLevel(levelNum) {
            const puzzleData = PUZZLE_LEVELS.find(p => p.level === levelNum);
            if (!puzzleData) {
                // No more levels - player wins!
                puzzleCompleted = true;
                showMessage('üéâ ALL PUZZLES COMPLETED!', '#00ff00');
                return;
            }
            
            puzzleObjective = puzzleData;
            puzzleProgress = 0;
            
            document.getElementById('puzzle-text').textContent = puzzleData.description;
            document.getElementById('puzzle-target').textContent = puzzleData.target;
            document.getElementById('puzzle-count').textContent = '0';
            
            showMessage(`üß© Level ${levelNum}: ${puzzleData.description}`, '#ff69b4');
        }
        
        function updatePuzzleProgress(eventType, data = {}) {
            if (gameMode !== 'puzzle' || !puzzleObjective || puzzleCompleted) return;
            
            let progressMade = false;
            
            switch (puzzleObjective.objective) {
                case 'merge_count':
                    if (eventType === 'merge') {
                        puzzleProgress++;
                        progressMade = true;
                    }
                    break;
                case 'create_tier':
                    if (eventType === 'create_tier' && data.tier === puzzleObjective.tier) {
                        puzzleProgress++;
                        progressMade = true;
                    }
                    break;
                case 'combo':
                    if (eventType === 'combo' && data.comboCount >= puzzleObjective.target) {
                        puzzleProgress = puzzleObjective.target; // Complete immediately
                        progressMade = true;
                    }
                    break;
                case 'floor_break':
                    if (eventType === 'floor_break') {
                        puzzleProgress++;
                        progressMade = true;
                    }
                    break;
                case 'score':
                    if (eventType === 'score_update') {
                        puzzleProgress = Math.min(data.score, puzzleObjective.target);
                        progressMade = data.score >= puzzleObjective.target;
                    }
                    break;
            }
            
            if (progressMade) {
                document.getElementById('puzzle-count').textContent = puzzleProgress;
                
                if (puzzleProgress >= puzzleObjective.target) {
                    completePuzzleLevel();
                }
            }
        }
        
        function completePuzzleLevel() {
            const reward = puzzleObjective.reward;
            score += reward;
            
            // Earn coins for puzzle completion
            const puzzleCoins = Math.floor(reward / 20); // Coins based on reward
            earnCoins(puzzleCoins, 'Puzzle Complete');
            
            showMessage(`üéâ PUZZLE COMPLETE! +${reward} bonus!`, '#00ff00');
            playSound('achievement');
            
            currentPuzzleLevel++;
            
            setTimeout(() => {
                loadPuzzleLevel(currentPuzzleLevel);
            }, 2000);
        }
        
        function stopPuzzleMode() {
            document.getElementById('puzzle-objective').style.display = 'none';
            currentPuzzleLevel = 1;
            puzzleProgress = 0;
            puzzleCompleted = false;
            puzzleObjective = null;
        }

        // === GAME OVER ===
        function checkGameOver() {
            if (gameOver) return;
            
            // Time Attack mode triggers game over when time runs out (handled in updateTimeAttackTimer)
            if (gameMode === 'timeattack') return;
            
            // Zen mode never triggers game over
            if (gameMode === 'zen') return;
            
            // Puzzle mode never triggers game over from object count
            if (gameMode === 'puzzle') return;
            
            // Daily challenge mode follows classic rules
            if (gameMode === 'daily' || gameMode === 'classic') {
                if (objects.length >= MAX_OBJECTS) triggerGameOver();
            }
        }

        function triggerGameOver() {
            gameOver = true;
            stopDangerSound();

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('dropzone_highscore', highScore);
            }

            // Save final stats
            if (sessionStartTime > 0) {
                const sessionSeconds = Math.floor((Date.now() - sessionStartTime) / 1000);
                stats.totalTimePlayed += sessionSeconds;
                sessionStartTime = 0; // Prevent double-counting
            }
            saveStats();
            checkAchievements();

            playSound('gameover');
            if (heldObject) releaseObject();
            if (spawnTimerId) clearInterval(spawnTimerId);
            if (powerupSpawnTimer) clearTimeout(powerupSpawnTimer);
            stopTimeAttackTimer();
            stopPuzzleMode();

            if (activePowerupOnField) {
                scene.remove(activePowerupOnField.mesh);
                scene.remove(activePowerupOnField.light);
                activePowerupOnField = null;
            }
            freezeActive = false;
            magnetActive = false;
            goldenTouchActive = false;
            document.getElementById('freeze-overlay').style.opacity = '0';
            hidePowerupIndicator();
            
            // Fade out music
            if (musicNodes && audioCtx) {
                musicNodes.masterGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1);
            }

            controls.unlock();
            
            // Check for new high score
            if (isNewHighScore(score)) {
                showNewHighScoreForm(score, level, totalMerges);
            }

            const overlay = document.getElementById('gameover-overlay');
            overlay.style.display = 'flex';
            document.getElementById('gameover-title').textContent = randomPick(GAMEOVER_MESSAGES);
            document.getElementById('gameover-score').textContent = score;
            document.getElementById('gameover-level').textContent = level;
            document.getElementById('gameover-merges').textContent = totalMerges;
            document.getElementById('gameover-highscore').textContent = highScore;
            document.getElementById('gameover-rank').textContent = getRank(score);
            if (sessionBestCombo >= 2) {
                document.getElementById('gameover-merges').textContent = totalMerges + ' (Best combo: x' + sessionBestCombo + ')';
            }

            document.getElementById('ui').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('combo-display').style.display = 'none';
            document.getElementById('tier-bar').style.display = 'none';
            document.getElementById('warning-text').style.display = 'none';
            document.getElementById('blocker').style.display = 'none';
        }

        function restartGame() {
            document.getElementById('gameover-overlay').style.display = 'none';
            [...objects].forEach(o => removeObject(o));

            if (activePowerupOnField) {
                scene.remove(activePowerupOnField.mesh);
                scene.remove(activePowerupOnField.light);
                activePowerupOnField = null;
            }

            score = 0; level = 1; levelMultiplier = 1.0; totalMerges = 0; comboCount = 0; comboStartTime = 0;
            
            // Apply starting bonus upgrade (+100 points per level)
            const startingUpgrade = (stats.upgrades.startingBonus || 0) * 100;
            if (startingUpgrade > 0) {
                score += startingUpgrade;
                earnCoins(Math.floor(startingUpgrade / 50), 'Starting Bonus');
            }
            gameOver = false; isFalling = false; floorBreakCooldown = false;
            goldenTouchActive = false; freezeActive = false; magnetActive = false;
            sessionYeets = 0; sessionBestCombo = 0;
            sessionStartTime = Date.now();
            stats.totalGamesPlayed++;
            slowMoActive = false; slowMoTimeScale = 1.0;
            if (slowMoTimer) { clearTimeout(slowMoTimer); slowMoTimer = null; }
            
            // Stop time attack timer if running
            stopTimeAttackTimer();
            stopPuzzleMode();
            
            // Reset timer display
            document.getElementById('timer').style.color = '#ffcc00';
            document.getElementById('timer').textContent = '60';
            
            document.getElementById('freeze-overlay').style.opacity = '0';
            hidePowerupIndicator();

            world.gravity.set(0, -20, 0);
            scene.background = new THREE.Color(0xfff8dc);

            if (floorBody) { try { world.removeBody(floorBody); } catch(e) {} }
            if (floorMesh) { try { scene.remove(floorMesh); } catch(e) {} }
            if (floorGrid) { try { scene.remove(floorGrid); } catch(e) {} }

            createFloor();

            playerBody.position.set(0, 5, 0);
            playerBody.velocity.set(0, 0, 0);

            for (let i = 0; i < 10; i++) spawnObject(randomSpawnTier());
            startSpawnTimer();
            schedulePowerupSpawn();
            updateUI();
            
            // Restart music
            stopMusic();
            
            controls.lock();
        }

        // === WARNING SYSTEM ===
        function updateWarningSystem() {
            const count = objects.length;
            const warningEl = document.getElementById('warning-text');
            const objCountEl = document.getElementById('objCount');

            // No warnings in Zen or Puzzle mode
            if (gameMode === 'zen' || gameMode === 'puzzle') {
                warningEl.style.display = 'none';
                objCountEl.style.color = '#f5e6c8';
                objCountEl.className = '';
                if (dangerSoundOsc) stopDangerSound();
                updateMusicIntensity(); // Update music for calm mode (calm intensity)
                return;
            }

            if (count >= 35) {
                warningEl.style.display = 'block';
                warningEl.className = 'pulse-fast';
                objCountEl.style.color = '#ff2222';
                objCountEl.className = 'flash-red';
                if (!dangerSoundOsc && audioCtx) startDangerSound();
            } else if (count >= 30) {
                warningEl.style.display = 'block';
                warningEl.className = 'pulse';
                objCountEl.style.color = '#ff2222';
                objCountEl.className = '';
                if (!dangerSoundOsc && audioCtx) startDangerSound();
            } else {
                warningEl.style.display = 'none';
                warningEl.className = '';
                objCountEl.style.color = '#f5e6c8';
                objCountEl.className = '';
                if (dangerSoundOsc) stopDangerSound();
            }
            
            // Update background music intensity based on object count
            updateMusicIntensity();
        }

        function buildTierBar() {
            const bar = document.getElementById('tier-bar');
            bar.innerHTML = '';
            TIERS.forEach((t, i) => {
                const icon = document.createElement('span');
                icon.className = 'tier-icon';
                icon.id = 'tier-icon-' + i;
                icon.textContent = TIER_EMOJIS[i];
                icon.title = t.name;
                bar.appendChild(icon);
                if (i < TIERS.length - 1) {
                    const arrow = document.createElement('span');
                    arrow.className = 'tier-arrow';
                    arrow.textContent = '‚Üí';
                    bar.appendChild(arrow);
                }
            });
        }

        function highlightTier(tierIndex) {
            TIERS.forEach((_, i) => {
                const icon = document.getElementById('tier-icon-' + i);
                if (icon) icon.className = 'tier-icon' + (i === tierIndex ? ' active' : '');
            });
        }

        // === PROCEDURAL TEXTURE GENERATORS ===
        function createCheckerboardTexture(size, tileCount, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const tileSize = size / tileCount;
            for (let y = 0; y < tileCount; y++) {
                for (let x = 0; x < tileCount; x++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? color1 : color2;
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    // Add subtle grout lines
                    ctx.strokeStyle = 'rgba(80,60,40,0.15)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(2, 2);
            return tex;
        }

        function createWoodTexture(size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            // Base wood color
            ctx.fillStyle = '#c49a6c';
            ctx.fillRect(0, 0, size, size);
            // Wood grain lines
            for (let i = 0; i < 60; i++) {
                const y = Math.random() * size;
                const alpha = 0.03 + Math.random() * 0.08;
                ctx.strokeStyle = `rgba(80, 50, 20, ${alpha})`;
                ctx.lineWidth = 1 + Math.random() * 3;
                ctx.beginPath();
                ctx.moveTo(0, y);
                // Wavy grain
                for (let x = 0; x < size; x += 10) {
                    ctx.lineTo(x, y + Math.sin(x * 0.02 + i) * (2 + Math.random() * 4));
                }
                ctx.stroke();
            }
            // Subtle knots
            for (let i = 0; i < 3; i++) {
                const kx = Math.random() * size;
                const ky = Math.random() * size;
                const kr = 5 + Math.random() * 15;
                const grad = ctx.createRadialGradient(kx, ky, 0, kx, ky, kr);
                grad.addColorStop(0, 'rgba(90,55,25,0.3)');
                grad.addColorStop(1, 'rgba(90,55,25,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(kx - kr, ky - kr, kr * 2, kr * 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createTileTexture(size, tileCountX, tileCountY, baseColor, groutColor) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const tileW = size / tileCountX;
            const tileH = size / tileCountY;
            const grout = 3;
            // Fill grout background
            ctx.fillStyle = groutColor || '#a09080';
            ctx.fillRect(0, 0, size, size);
            // Draw tiles with slight color variation
            const base = new THREE.Color(baseColor);
            for (let y = 0; y < tileCountY; y++) {
                for (let x = 0; x < tileCountX; x++) {
                    const variation = 0.95 + Math.random() * 0.10;
                    const c = base.clone().multiplyScalar(variation);
                    ctx.fillStyle = `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`;
                    ctx.fillRect(x * tileW + grout/2, y * tileH + grout/2, tileW - grout, tileH - grout);
                    // Subtle bevel highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.06)';
                    ctx.fillRect(x * tileW + grout/2, y * tileH + grout/2, tileW - grout, 2);
                    ctx.fillRect(x * tileW + grout/2, y * tileH + grout/2, 2, tileH - grout);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // === FLOOR CREATION (reused on restart & level reset) ===
        function createFloor(color) {
            const floorColor = color || 0xc49a6c;
            // Checkerboard kitchen floor
            const floorGeo = new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE);
            const floorTex = createCheckerboardTexture(512, 10, '#ddd0b8', '#c49a6c');
            const floorMatVisual = new THREE.MeshStandardMaterial({
                map: floorTex,
                color: floorColor,
                roughness: 0.6,
                metalness: 0.05,
                side: THREE.DoubleSide
            });
            floorMesh = new THREE.Mesh(floorGeo, floorMatVisual);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            // Remove the ugly grid helper ‚Äî the checkerboard does this better
            floorGrid = new THREE.Group(); // empty placeholder so removal code doesn't break
            scene.add(floorGrid);

            floorBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: groundMat
            });
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(floorBody);
        }

        function createRoom(groundMatParam) {
            groundMat = groundMatParam;

            // Floor
            createFloor();

            // Kitchen tile walls ‚Äî subway tile pattern, warm white
            const wallTex = createTileTexture(512, 8, 6, 0xe8ddd0, '#b0a090');
            const wallPositions = [
                { pos: [0, WALL_HEIGHT/2, -ROOM_SIZE/2], rot: [0, 0, 0] },
                { pos: [0, WALL_HEIGHT/2, ROOM_SIZE/2], rot: [0, Math.PI, 0] },
                { pos: [-ROOM_SIZE/2, WALL_HEIGHT/2, 0], rot: [0, Math.PI/2, 0] },
                { pos: [ROOM_SIZE/2, WALL_HEIGHT/2, 0], rot: [0, -Math.PI/2, 0] }
            ];

            wallPositions.forEach(w => {
                const wallGeo = new THREE.PlaneGeometry(ROOM_SIZE, WALL_HEIGHT);
                const wallMat = new THREE.MeshStandardMaterial({
                    map: wallTex.clone(),
                    color: 0xf5ece0,
                    side: THREE.DoubleSide,
                    roughness: 0.7,
                    metalness: 0.0
                });
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(...w.pos);
                wall.rotation.set(...w.rot);
                wall.receiveShadow = true;
                scene.add(wall);

                const wallBody = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Plane(),
                    material: groundMat
                });
                wallBody.position.set(...w.pos);
                wallBody.quaternion.setFromEuler(...w.rot);
                world.addBody(wallBody);
            });

            // Add baseboards (dark wooden trim at bottom of walls)
            const baseboardPositions = [
                { pos: [0, 0.15, -ROOM_SIZE/2 + 0.01], rot: [0, 0, 0] },
                { pos: [0, 0.15, ROOM_SIZE/2 - 0.01], rot: [0, Math.PI, 0] },
                { pos: [-ROOM_SIZE/2 + 0.01, 0.15, 0], rot: [0, Math.PI/2, 0] },
                { pos: [ROOM_SIZE/2 - 0.01, 0.15, 0], rot: [0, -Math.PI/2, 0] }
            ];
            const baseboardMat = new THREE.MeshStandardMaterial({
                color: 0x5a3a1a, roughness: 0.6, metalness: 0.1
            });
            baseboardPositions.forEach(b => {
                const geo = new THREE.PlaneGeometry(ROOM_SIZE, 0.3);
                const mesh = new THREE.Mesh(geo, baseboardMat);
                mesh.position.set(...b.pos);
                mesh.rotation.set(...b.rot);
                scene.add(mesh);
            });

            // Add a ceiling (subtle, so it doesn't feel like an open box)
            const ceilingGeo = new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE);
            const ceilingMat = new THREE.MeshStandardMaterial({
                color: 0xfaf5ed, roughness: 0.9, metalness: 0.0, side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = WALL_HEIGHT;
            scene.add(ceiling);
        }

        // === OBJECT BEHAVIOR SYSTEM ===
        function initializeObjectBehavior(obj) {
            const behavior = TIERS[obj.tier].behavior;
            if (!behavior) return;
            
            obj.behavior = behavior;
            obj.behaviorTime = 0;
            obj.behaviorEffects = [];
            
            // Create visual effects based on behavior
            switch (behavior) {
                case 'hot':
                    createHotObjectEffects(obj);
                    break;
                case 'ice':
                    createIceObjectEffects(obj);
                    break;
                case 'bouncy':
                    createBouncyObjectEffects(obj);
                    break;
            }
        }
        
        function createHotObjectEffects(obj) {
            // Orange glow and flame particles
            const geometry = new THREE.SphereGeometry(obj.mesh.scale.x * 1.2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff4400, 
                transparent: true, 
                opacity: 0.3 
            });
            const glow = new THREE.Mesh(geometry, material);
            obj.mesh.add(glow);
            
            obj.hotGlow = glow;
            obj.behaviorEffects.push(glow);
        }
        
        function createIceObjectEffects(obj) {
            // Blue-white frost glow
            const geometry = new THREE.SphereGeometry(obj.mesh.scale.x * 1.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x88ddff, 
                transparent: true, 
                opacity: 0.4 
            });
            const frost = new THREE.Mesh(geometry, material);
            obj.mesh.add(frost);
            
            obj.frostGlow = frost;
            obj.behaviorEffects.push(frost);
        }
        
        function createBouncyObjectEffects(obj) {
            // Subtle sparkle effect for extra bouncy objects
            const geometry = new THREE.SphereGeometry(obj.mesh.scale.x * 1.05, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffcc, 
                transparent: true, 
                opacity: 0.2 
            });
            const sparkle = new THREE.Mesh(geometry, material);
            obj.mesh.add(sparkle);
            
            obj.sparkleGlow = sparkle;
            obj.behaviorEffects.push(sparkle);
        }
        
        function updateObjectBehaviors() {
            const time = Date.now() * 0.001;
            
            objects.forEach(obj => {
                if (!obj.behavior) return;
                
                obj.behaviorTime += 0.016; // ~60fps
                
                switch (obj.behavior) {
                    case 'hot':
                        updateHotBehavior(obj, time);
                        break;
                    case 'ice':
                        updateIceBehavior(obj, time);
                        break;
                    case 'bouncy':
                        updateBouncyBehavior(obj, time);
                        break;
                }
            });
        }
        
        function updateHotBehavior(obj, time) {
            if (obj.hotGlow) {
                // Pulsing hot glow
                obj.hotGlow.material.opacity = 0.2 + Math.sin(time * 4) * 0.1;
                obj.hotGlow.scale.setScalar(1.0 + Math.sin(time * 3) * 0.1);
            }
            
            // Heat nearby objects (slow effect for gameplay balance)
            if (obj.behaviorTime % 3 < 0.1) { // Every 3 seconds
                objects.forEach(other => {
                    if (other === obj) return;
                    const distance = obj.mesh.position.distanceTo(other.mesh.position);
                    if (distance < 2.0) {
                        // Slight upward impulse from heat
                        other.body.applyImpulse(new CANNON.Vec3(0, 0.5, 0), other.body.position);
                    }
                });
            }
        }
        
        function updateIceBehavior(obj, time) {
            if (obj.frostGlow) {
                // Gentle ice glow pulse
                obj.frostGlow.material.opacity = 0.3 + Math.sin(time * 2) * 0.1;
            }
            
            // Slow nearby objects (subtle effect)
            if (obj.behaviorTime % 2 < 0.1) { // Every 2 seconds
                objects.forEach(other => {
                    if (other === obj) return;
                    const distance = obj.mesh.position.distanceTo(other.mesh.position);
                    if (distance < 1.5) {
                        // Dampen velocity slightly
                        other.body.velocity.scale(0.95, other.body.velocity);
                    }
                });
            }
        }
        
        function updateBouncyBehavior(obj, time) {
            if (obj.sparkleGlow) {
                // Twinkling sparkle effect
                obj.sparkleGlow.material.opacity = 0.1 + Math.sin(time * 6) * 0.1;
                obj.sparkleGlow.rotation.y += 0.02;
            }
            
            // Extra bounce on collision (handled in physics material, but add visual flair)
            if (obj.body.velocity.length() > 3) {
                if (obj.sparkleGlow) {
                    obj.sparkleGlow.material.opacity = Math.min(0.5, 0.1 + obj.body.velocity.length() * 0.05);
                }
            }
        }

        function spawnObject(tier) {
            if (tier >= TIERS.length) return null;
            if (gameOver) return null;

            const t = TIERS[tier];

            // Clone GLTF model (or fallback)
            const mesh = cloneModelForTier(tier);

            const x = (Math.random() - 0.5) * (ROOM_SIZE - 4);
            const z = (Math.random() - 0.5) * (ROOM_SIZE - 4);
            const y = 8 + Math.random() * 3;

            mesh.position.set(x, y, z);
            scene.add(mesh);

            const body = new CANNON.Body({
                mass: t.mass,
                shape: t.physicsShape(),
                position: new CANNON.Vec3(x, y, z),
                material: tierMaterials[tier]
            });
            world.addBody(body);

            const obj = { mesh, body, tier, id: Math.random().toString(36).substr(2, 9) };
            
            // Initialize object behavior
            initializeObjectBehavior(obj);
            
            objects.push(obj);
            stats.totalObjectsSpawned++;
            playSound('spawn');
            updateUI();
            return obj;
        }

        function handleCollision(event) {
            if (gameOver) return;
            const bodyA = event.bodyA;
            const bodyB = event.bodyB;

            const objA = objects.find(o => o.body === bodyA);
            const objB = objects.find(o => o.body === bodyB);

            // Birthday Cake (tier 5) hits floor ‚Üí break floor
            if (!isFalling && !floorBreakCooldown) {
                if ((objA && objA.tier === 5 && bodyB === floorBody) ||
                    (objB && objB.tier === 5 && bodyA === floorBody)) {
                    const cake = objA && objA.tier === 5 ? objA : objB;
                    if (cake) removeObject(cake);
                    breakFloor();
                    return;
                }
            }

            // Squish animation when objects hit floor or walls
            if ((objA && bodyB === floorBody && objA.body.velocity.length() > 2) ||
                (objB && bodyA === floorBody && objB.body.velocity.length() > 2)) {
                const hitObj = objA && bodyB === floorBody ? objA : objB;
                if (hitObj && !hitObj.squishing) {
                    triggerSquishAnimation(hitObj);
                }
            }

            // Merge same-tier objects
            if (objA && objB && objA.tier === objB.tier && objA.tier < TIERS.length - 1) {
                if (merging.has(objA.id) || merging.has(objB.id)) return;
                merging.add(objA.id);
                merging.add(objB.id);

                const midpoint = new CANNON.Vec3(
                    (bodyA.position.x + bodyB.position.x) / 2,
                    (bodyA.position.y + bodyB.position.y) / 2,
                    (bodyA.position.z + bodyB.position.z) / 2
                );

                const oldTier = objA.tier;
                removeObject(objA);
                removeObject(objB);
                merging.delete(objA.id);
                merging.delete(objB.id);

                // Golden touch: skip a tier
                let newTier = oldTier + 1;
                if (goldenTouchActive && newTier < TIERS.length - 1) {
                    newTier++;
                    goldenTouchActive = false;
                    hidePowerupIndicator();
                }

                const newObj = spawnObject(newTier);
                if (newObj) {
                    newObj.body.position.copy(midpoint);
                    newObj.mesh.position.copy(midpoint);

                    // Juice/splash particles in realistic juice color
                    const particleCounts = [10, 15, 20, 25, 30, 35];
                    const pCount = particleCounts[Math.min(newTier, particleCounts.length - 1)];
                    const juiceColor = JUICE_COLORS[Math.min(oldTier, JUICE_COLORS.length - 1)]; // Use OLD tier's juice color for splatter
                    spawnParticles(midpoint, juiceColor, pCount, 0.08 + newTier * 0.03);

                    // Chromatic aberration flash for high-tier merges (Pumpkin & Cake)
                    if (newTier >= 4) {
                        const intensity = newTier === 4 ? 0.006 : 0.012; // Stronger for cake
                        const duration = newTier === 4 ? 300 : 500; // Longer for cake
                        triggerChromaticAberration(intensity, duration);
                    }

                    // Push nearby objects
                    const pushForce = 15 + newTier * 5;
                    objects.forEach(o => {
                        if (o !== newObj) {
                            const dir = new CANNON.Vec3();
                            o.body.position.vsub(midpoint, dir);
                            const dist = dir.length();
                            if (dist < 5) {
                                dir.normalize();
                                dir.scale(pushForce / (dist + 1), dir);
                                o.body.applyImpulse(dir);
                            }
                        }
                    });
                }

                totalMerges++;
                stats.totalMergesAllTime++;
                
                // Track puzzle progress for merges
                updatePuzzleProgress('merge');
                updatePuzzleProgress('create_tier', { tier: newTier });

                // Combo system
                comboCount++;
                if (comboTimer) clearTimeout(comboTimer);
                comboStartTime = Date.now();
                // Apply combo time upgrade (+1s per level)
                const comboUpgrade = (stats.upgrades.comboTime || 0) * 1000; // +1000ms per level
                comboTimeLeft = COMBO_WINDOW + comboUpgrade;
                comboTimer = setTimeout(() => {
                    comboCount = 0;
                    document.getElementById('combo-text').style.display = 'none';
                }, COMBO_WINDOW);

                const multiplier = Math.max(1, comboCount);
                const baseScore = TIERS[newTier].mass * 10;
                const earnedScore = baseScore * multiplier;
                
                // Apply score upgrade bonus
                const scoreUpgrade = (stats.upgrades.scoreMultiplier || 0) * 0.2; // +20% per level
                const scoreMultiplier = levelMultiplier * (1 + scoreUpgrade);
                
                const finalScore = Math.floor(earnedScore * scoreMultiplier);
                score += finalScore;
                
                // Earn coins from merges (1 coin per 10 score, minimum 1)
                const coinsEarned = Math.max(1, Math.floor(finalScore / 10));
                earnCoins(coinsEarned, 'Merge');

                // Track combo stats
                if (comboCount > sessionBestCombo) sessionBestCombo = comboCount;
                if (comboCount > stats.highestCombo) stats.highestCombo = comboCount;
                
                // Track puzzle progress for combos
                updatePuzzleProgress('combo', { comboCount });

                if (comboCount >= 2) {
                    playSound('combo', comboCount);
                    showMessage('x' + comboCount + ' COMBO! +' + finalScore);
                    const ct = document.getElementById('combo-text');
                    ct.style.display = 'block';
                    ct.textContent = 'x' + comboCount + ' COMBO!';
                    ct.style.transform = 'scale(1.3)';
                    setTimeout(() => ct.style.transform = 'scale(1)', 100);
                    
                    // Trigger slow-mo on 3+ combos
                    if (comboCount >= 3) {
                        activateSlowMo();
                    }
                } else {
                    showMessage(randomPick(MERGE_MESSAGES) + ' +' + earnedScore);
                }

                checkAchievements();
                
                // Track puzzle progress for score
                updatePuzzleProgress('score_update', { score });

                playSound('merge', newTier);
                highlightTier(newTier);
                updateUI();
            }
        }

        function spawnParticles(position, color, count, size) {
            const pSize = size || 0.08;
            for (let i = 0; i < count; i++) {
                // Juice droplet shape: slightly elongated sphere for splatter realism
                const dropletScale = 0.7 + Math.random() * 0.6;
                const geo = new THREE.SphereGeometry(pSize * dropletScale, 6, 6);
                geo.scale(1, 0.6 + Math.random() * 0.8, 1); // Flatten slightly for droplet shape
                
                // Color variation for natural juice splatter effect
                const baseColor = new THREE.Color(color);
                const variation = 0.85 + Math.random() * 0.3;
                const juiceColor = baseColor.clone().multiplyScalar(variation);
                
                const mat = new THREE.MeshBasicMaterial({ 
                    color: juiceColor, 
                    transparent: true, 
                    opacity: 0.9 + Math.random() * 0.1,
                    shininess: 30 // Slight juice glossiness
                });
                const p = new THREE.Mesh(geo, mat);
                p.position.set(position.x, position.y, position.z);
                
                // Random rotation for organic feel
                p.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                scene.add(p);

                // Juice splatter motion: wide horizontal spread, shorter arc
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 12, // Wider horizontal spread
                    Math.random() * 4 + 2,      // Less vertical, more splatter-like
                    (Math.random() - 0.5) * 12
                );
                
                // Slight spin for juice droplets
                const rotVel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );

                const tick = () => {
                    p.position.add(vel.clone().multiplyScalar(0.016));
                    vel.y -= 0.35; // Faster gravity for droplets
                    vel.multiplyScalar(0.98); // Air resistance
                    
                    p.rotation.x += rotVel.x;
                    p.rotation.y += rotVel.y;
                    p.rotation.z += rotVel.z;
                    
                    mat.opacity -= 0.04; // Faster fade for juice effect
                    p.scale.multiplyScalar(0.96); // Faster shrink
                    
                    if (mat.opacity > 0 && p.position.y > -2) requestAnimationFrame(tick);
                    else scene.remove(p);
                };
                tick();
            }
        }

        // Crumb-like brown particles for floor break
        function spawnFloorBreakParticles(position) {
            const crumbColors = [0x8B6914, 0xa07828, 0x6B4F1A, 0xc49a6c, 0x5a3e10];
            for (let i = 0; i < 30; i++) {
                const sz = 0.06 + Math.random() * 0.1;
                const geo = new THREE.BoxGeometry(sz, sz * 0.4, sz);
                const color = crumbColors[Math.floor(Math.random() * crumbColors.length)];
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
                const p = new THREE.Mesh(geo, mat);
                p.position.set(
                    position.x + (Math.random() - 0.5) * 4,
                    position.y,
                    position.z + (Math.random() - 0.5) * 4
                );
                scene.add(p);

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 6,
                    Math.random() * 4 + 2,
                    (Math.random() - 0.5) * 6
                );
                const rotSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                const tick = () => {
                    p.position.add(vel.clone().multiplyScalar(0.016));
                    vel.y -= 0.15;
                    p.rotation.x += rotSpeed.x;
                    p.rotation.z += rotSpeed.z;
                    mat.opacity -= 0.018;
                    if (mat.opacity > 0) requestAnimationFrame(tick);
                    else scene.remove(p);
                };
                tick();
            }
        }

        // Squish/wobble animation when objects land
        function triggerSquishAnimation(obj) {
            if (obj.squishing) return; // Already squishing
            obj.squishing = true;
            
            const originalScale = obj.mesh.scale.clone();
            const duration = 400; // milliseconds
            const squishFactor = 0.7; // How much to squash (0.7 = 30% shorter)
            const stretchFactor = 1.3; // How much to stretch width (compensate for lost height)
            
            // Store original scale if not already stored
            if (!obj.originalScale) {
                obj.originalScale = originalScale.clone();
            }
            
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease-out bounce curve for natural squish
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                if (progress < 0.3) {
                    // Squish phase (first 30% of animation)
                    const squishProgress = progress / 0.3;
                    const squishAmount = squishFactor + (1 - squishFactor) * (1 - squishProgress);
                    const stretchAmount = 1 + (stretchFactor - 1) * squishProgress;
                    
                    obj.mesh.scale.set(
                        originalScale.x * stretchAmount,
                        originalScale.y * squishAmount,
                        originalScale.z * stretchAmount
                    );
                } else {
                    // Bounce back phase (last 70% of animation)
                    const bounceProgress = (progress - 0.3) / 0.7;
                    const bounceEase = 1 - Math.pow(1 - bounceProgress, 2);
                    
                    // Slight overshoot then settle
                    const overshoot = 1.05 - 0.05 * bounceEase;
                    
                    obj.mesh.scale.set(
                        originalScale.x * (stretchFactor - (stretchFactor - overshoot) * bounceEase),
                        originalScale.y * (squishFactor + (overshoot - squishFactor) * bounceEase),
                        originalScale.z * (stretchFactor - (stretchFactor - overshoot) * bounceEase)
                    );
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Reset to original scale
                    obj.mesh.scale.copy(originalScale);
                    obj.squishing = false;
                }
            };
            
            animate();
        }

        function removeObject(obj) {
            if (heldObject === obj) releaseObject();
            scene.remove(obj.mesh);
            world.removeBody(obj.body);
            objects = objects.filter(o => o.id !== obj.id);
        }

        function breakFloor() {
            if (isFalling) return;
            isFalling = true;
            stats.totalFloorsSmashed++;

            const floorBonus = Math.floor(100 * level * levelMultiplier);
            score += floorBonus;
            
            // Earn bonus coins for floor breaking
            const floorCoins = Math.floor(level * 2); // 2 coins per level
            earnCoins(floorCoins, 'Floor Break');
            
            showMessage(randomPick(FLOORBREAK_MESSAGES) + ' +' + floorBonus);
            playSound('floor_break');
            screenShake = 1.0;
            
            // Track puzzle progress for floor breaking
            updatePuzzleProgress('floor_break');
            
            // Camera zoom punch effect
            triggerCameraZoomPunch();

            if (floorBody) world.removeBody(floorBody);
            if (floorMesh) scene.remove(floorMesh);
            if (floorGrid) scene.remove(floorGrid);

            // Crumb/wood debris instead of glass shards
            for (let i = 0; i < 20; i++) {
                const w = 1 + Math.random();
                const dg = new THREE.BoxGeometry(w, 0.1, 1 + Math.random());
                const crumbColor = [0xc49a6c, 0xa08050, 0x8B6914][Math.floor(Math.random() * 3)];
                const dm = new THREE.MeshStandardMaterial({ color: crumbColor, roughness: 0.8 });
                const debris = new THREE.Mesh(dg, dm);
                debris.position.set((Math.random() - 0.5) * ROOM_SIZE, -0.1, (Math.random() - 0.5) * ROOM_SIZE);
                scene.add(debris);

                const fs = 5 + Math.random() * 10;
                const rs = Math.random() * 0.2;
                const fall = () => {
                    debris.position.y -= fs * 0.016;
                    debris.rotation.x += rs;
                    debris.rotation.z += rs;
                    if (debris.position.y > -50) requestAnimationFrame(fall);
                    else scene.remove(debris);
                };
                setTimeout(fall, i * 50);
            }

            // Also spawn crumb particles
            spawnFloorBreakParticles(new CANNON.Vec3(0, 0, 0));

            setTimeout(() => resetLevel(), 2500);
        }

        function updateLevelMultiplier() {
            // Level multiplier increases by 20% per level: 1.0x, 1.2x, 1.44x, 1.73x, etc.
            levelMultiplier = 1.0 + (level - 1) * 0.2;
        }

        function resetLevel() {
            level++;
            stats.totalLevelsReached++;
            if (level > stats.highestLevel) stats.highestLevel = level;
            updateLevelMultiplier();
            checkAchievements();
            isFalling = false;
            floorBreakCooldown = true;
            setTimeout(() => floorBreakCooldown = false, 1000);

            // Check for boss level (every 5 levels)
            const isBossLevel = level % 5 === 0;
            
            const gravityMod = isBossLevel ? 1.2 + Math.random() * 0.3 : 0.7 + Math.random() * 0.6;
            world.gravity.set(0, -20 * gravityMod, 0);

            // Kitchen-themed floor colors per level
            const floorColors = [0xc49a6c, 0xb8946a, 0xd4a86c, 0xba8c58, 0xc8a070, 0xd0986a];
            const levelColor = floorColors[level % floorColors.length];

            // Subtle background color shift ‚Äî still warm
            const hue = (level * 0.05) % 1;
            scene.background = new THREE.Color().setHSL(hue * 0.12 + 0.08, 0.25, 0.9);

            let levelMessage = 'LEVEL ' + level + '!';
            let spawnCount = 5;
            
            if (isBossLevel) {
                levelMessage = 'üëë BOSS LEVEL ' + level + '! üëë';
                spawnCount = 8; // Boss levels spawn more objects
                
                // Boss level special effects
                setTimeout(() => {
                    showMessage('üî• CHALLENGE MODE! üî•');
                    // Spawn some higher tier objects for extra challenge
                    setTimeout(() => spawnObject(3), 1000); // Watermelon
                    setTimeout(() => spawnObject(3), 1500); // Another watermelon
                    setTimeout(() => spawnObject(4), 2000); // Pumpkin
                }, 1500);
            } else {
                const gravityText = gravityMod < 0.85 ? ' ü™∂ LOW GRAVITY' : gravityMod > 1.15 ? ' ü™® HIGH GRAVITY' : '';
                levelMessage += gravityText;
            }
            
            showMessage(levelMessage);
            playSound('level');
            document.getElementById('level').textContent = level;

            createFloor(levelColor);

            // Remove cakes
            objects.filter(o => o.tier === 5).forEach(a => removeObject(a));

            playerBody.position.set(0, 5, 0);
            playerBody.velocity.set(0, 0, 0);

            objects.forEach(obj => {
                obj.body.position.set(
                    (Math.random() - 0.5) * (ROOM_SIZE - 4),
                    5 + Math.random() * 5,
                    (Math.random() - 0.5) * (ROOM_SIZE - 4)
                );
                obj.body.velocity.set(0, 0, 0);
            });

            // Boss levels spawn more objects and with higher tiers
            for (let i = 0; i < spawnCount; i++) {
                const tier = isBossLevel && i < 3 ? Math.min(2 + Math.floor(Math.random() * 2), 4) : randomSpawnTier();
                spawnObject(tier);
            }
            startSpawnTimer();
            updateUI();
        }

        function grabObject() {
            if (heldObject) { releaseObject(); return; }

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            // Collect all meshes from objects (including nested children of GLTF groups)
            const meshes = [];
            const meshToObj = new Map();
            objects.forEach(o => {
                o.mesh.traverse((child) => {
                    if (child.isMesh) {
                        meshes.push(child);
                        meshToObj.set(child, o);
                    }
                });
                // Also add the group itself so intersectObjects can work on it
                meshes.push(o.mesh);
                meshToObj.set(o.mesh, o);
            });

            const intersects = raycaster.intersectObjects(meshes, true);

            if (intersects.length > 0 && intersects[0].distance < GRAB_DISTANCE) {
                // Walk up to find which game object this belongs to
                let hitObj = null;
                let current = intersects[0].object;
                while (current) {
                    if (meshToObj.has(current)) {
                        hitObj = meshToObj.get(current);
                        break;
                    }
                    current = current.parent;
                }
                if (hitObj) {
                    heldObject = hitObj;
                    springConstraint = new CANNON.Spring(playerBody, hitObj.body, {
                        localAnchorA: new CANNON.Vec3(0, 0, -3),
                        localAnchorB: new CANNON.Vec3(0, 0, 0),
                        restLength: 0, stiffness: 50, damping: 5
                    });
                    document.getElementById('holding').textContent = TIERS[hitObj.tier].name;
                    // Emissive glow on grab
                    setMeshEmissive(hitObj.mesh, 0.3);
                    playSound('grab');
                    showMessage(randomPick(GRAB_MESSAGES));
                    highlightTier(hitObj.tier);
                }
            }
        }

        function setMeshEmissive(mesh, intensity) {
            mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.emissiveIntensity = intensity;
                    if (intensity > 0.1) {
                        child.material.emissive = child.material.emissive || new THREE.Color(0xffffff);
                    }
                }
            });
        }

        function releaseObject() {
            if (heldObject) {
                setMeshEmissive(heldObject.mesh, 0.05);
                heldObject = null;
                springConstraint = null;
                document.getElementById('holding').textContent = 'Nothing';
            }
        }

        function yeetObject() {
            if (heldObject) {
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(camera.quaternion);
                heldObject.body.applyImpulse(
                    new CANNON.Vec3(dir.x * YEET_FORCE, dir.y * YEET_FORCE, dir.z * YEET_FORCE)
                );
                
                // Add spin/tumble angular velocity for satisfying yeet physics
                const spinStrength = 15 + Math.random() * 10; // 15-25 spin speed
                heldObject.body.angularVelocity.set(
                    (Math.random() - 0.5) * spinStrength, // Random X spin
                    (Math.random() - 0.5) * spinStrength, // Random Y spin
                    (Math.random() - 0.5) * spinStrength  // Random Z spin
                );
                
                releaseObject();
                showMessage(randomPick(YEET_MESSAGES));
                playSound('yeet');
                sessionYeets++;
                stats.totalYeetsAllTime++;
                checkAchievements();
            }
        }

        function showMessage(text, color) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.color = color || '#ffcc00';
            msg.style.textShadow = `0 0 30px ${color || '#ffcc00'}`;
            msg.className = 'show';
            setTimeout(() => msg.className = '', 1200);
        }

        function updateUI() {
            document.getElementById('objCount').textContent = objects.length + '/' + MAX_OBJECTS;
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('multiplier').textContent = levelMultiplier.toFixed(1) + 'x';
            document.getElementById('rank-display').textContent = getRank(score);
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('dropzone_highscore', highScore);
            }
            document.getElementById('highscore').textContent = highScore;
            
            // Show/hide puzzle objective display
            if (gameMode === 'puzzle') {
                document.getElementById('puzzle-objective').style.display = 'block';
            } else {
                document.getElementById('puzzle-objective').style.display = 'none';
            }
            
            updateWarningSystem();
            checkDailyChallengeProgress();
        }

        function onKeyDown(e) {
            if (gameOver) return;
            
            // Escape key: toggle pause
            if (e.code === 'Escape') {
                e.preventDefault();
                if (isPaused) {
                    unpauseGame();
                } else if (controls.isLocked) {
                    pauseGame();
                }
                return;
            }
            
            if (isPaused) return; // No gameplay input while paused
            
            switch (e.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': keys.space = true; e.preventDefault(); break;
                case 'ShiftLeft': case 'ShiftRight': keys.shift = true; break;
                case 'KeyE': grabObject(); break;
                case 'KeyQ': yeetObject(); break;
            }
        }

        function onKeyUp(e) {
            switch (e.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
                case 'ShiftLeft': case 'ShiftRight': keys.shift = false; break;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // === CROSSHAIR AIM CHECK ===
        function updateCrosshair() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const meshes = [];
            objects.forEach(o => {
                o.mesh.traverse((child) => { if (child.isMesh) meshes.push(child); });
            });
            const intersects = raycaster.intersectObjects(meshes, true);
            const ch = document.getElementById('crosshair');
            if (intersects.length > 0 && intersects[0].distance < GRAB_DISTANCE) {
                ch.classList.add('target');
            } else {
                ch.classList.remove('target');
            }
        }

        // === COMBO TIMER UI ===
        function updateComboUI() {
            if (comboCount >= 2 && comboStartTime > 0) {
                const elapsed = Date.now() - comboStartTime;
                const remaining = Math.max(0, COMBO_WINDOW - elapsed);
                document.getElementById('combo-timer').style.width = (remaining / COMBO_WINDOW * 100) + '%';
            } else {
                document.getElementById('combo-timer').style.width = '0%';
            }
        }

        // === SAME-TIER PROXIMITY GLOW ===
        let glowTime = 0;
        function updateMergeHints() {
            glowTime += 0.03;
            const pulse = 0.05 + Math.sin(glowTime * 3) * 0.04;
            objects.forEach(obj => {
                if (obj === heldObject) return;
                let nearMatch = false;
                for (const other of objects) {
                    if (other === obj || other.tier !== obj.tier || other === heldObject) continue;
                    const dx = obj.body.position.x - other.body.position.x;
                    const dy = obj.body.position.y - other.body.position.y;
                    const dz = obj.body.position.z - other.body.position.z;
                    if (Math.sqrt(dx*dx + dy*dy + dz*dz) < 4) { nearMatch = true; break; }
                }
                setMeshEmissive(obj.mesh, nearMatch ? pulse + 0.1 : 0.05);
            });
        }

        // === GAME LOOP ===
        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked && !gameOver && !isPaused) {
                direction.z = Number(keys.w) - Number(keys.s);
                direction.x = Number(keys.d) - Number(keys.a);
                direction.normalize();

                const speed = keys.shift ? SPRINT_SPEED : MOVE_SPEED;
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                camDir.y = 0; camDir.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(camDir, new THREE.Vector3(0, 1, 0));

                const targetVelX = (camDir.x * direction.z + right.x * direction.x) * speed;
                const targetVelZ = (camDir.z * direction.z + right.z * direction.x) * speed;

                playerBody.wakeUp();
                playerBody.velocity.x = targetVelX;
                playerBody.velocity.z = targetVelZ;

                if (keys.space && canJump && playerBody.position.y < 2.5) {
                    playerBody.velocity.y = JUMP_FORCE;
                    canJump = false;
                    playSound('jump');
                    stats.totalJumpsAllTime++;
                    setTimeout(() => canJump = true, 400);
                }

                if (springConstraint && heldObject) springConstraint.applyForce();
                applyMagnetForce();

                // Apply slow-mo time scaling to physics
                const timeStep = (1/60) * slowMoTimeScale;
                world.step(timeStep);

                controls.getObject().position.copy(playerBody.position);

                // Death plane
                if (playerBody.position.y < -30 && !isFalling) {
                    playerBody.position.set(0, 5, 0);
                    playerBody.velocity.set(0, 0, 0);
                    showMessage('RESPAWN!');
                }

                // Sync objects ‚Äî position + rotation
                objects.forEach(obj => {
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                });

                updatePowerupVisuals();
                checkPowerupPickup();
                updateCrosshair();
                updateComboUI();
                updateMergeHints();
                updateObjectBehaviors();
            }

            // Update music intensity based on game state
            if (musicPlaying && !isPaused) updateMusicIntensity();

            // Periodic stats save (every ~10 seconds via frame counting)
            if (!window._statsSaveCounter) window._statsSaveCounter = 0;
            window._statsSaveCounter++;
            if (window._statsSaveCounter % 600 === 0) { // ~10 seconds at 60fps
                saveStats();
                checkAchievements();
            }

            // Screen shake
            if (screenShake > 0) {
                camera.position.x += (Math.random() - 0.5) * screenShake * 0.5;
                camera.position.y += (Math.random() - 0.5) * screenShake * 0.3;
                screenShake *= 0.9;
                if (screenShake < 0.01) screenShake = 0;
            }

            // Render with post-processing
            try {
                composer.render();
            } catch(e) {
                // Fallback to basic render if post-processing fails
                renderer.render(scene, camera);
            }
        }

        // Setup mobile controls after all functions are defined
        setupMobileControls();
    </script>
</body>
</html>
